C++

## 1. Welcome(HelloWorld)

> 【BV1VJ411M7WR】

> 如果在C++中写垃圾代码，C++绝对比C#和Java慢，因为后者语言运行时会优化很多东西而C++不会



## 2. Setup

```C++
#include <iostream>

int main()
{
	std::cout << "Hello world!" << std::endl;
	std::cin.get();
}
```



## 3. How C++ works

- **预处理指令**，即以 `#` 开头的代码。当编译器收到一个源文件时，所做的第一件事就是预处理所有的预处理指令。
- **`#include <>`** 是找到一个文件，上面代码中是找到叫 `iostream` 的文件，该文件里的所内容都会被复制粘贴到目前这个文件里。
- **`<file>`** include的这些文件一般被称为 header file（头文件）。
- **`cout`** include  `iostream` 文件是因为我们代码中用到了 `cout`，它是我们能够打印东西到 console （控制台）
- **`main` 函数**，每个 C++ 程序都有类似这个的东西，被称为入口点（entry point），也就是程序的入口。`main` 函数返回类型是 `int`，但是我们并没有从主函数中返回任何值，这是`main` 函数在没有返回的情况下默认返回0。
- `<<` 其实是重载符号

---

> 所有 .cpp 文件都会被编译，而头文件不会。因为在头文件 include 到当前文件时候进行了编译。
>
> 每一个 .cpp 文件时分别进行编译的，编译后生成一个 object 文件，在windows中扩展名时`.obj`。当有了一个个 .obj 文件后，需要通过某种方式将他们连接起来，这就是 `linker`(连接器)的用武之处了。

----

我们在**单独的.cpp文件中定义**方法，**在main.cpp中调用**该方法时需要先声明，即向该文件承诺有相应的方法存在，以保证linker工作时不会出错，这必须一致，否则找不到的话会报出linker error。如果有明明错误，单独编译main.cpp时没有问题的，只有在生成时才会报错

![image-20211103095214622](E:\newbie\cpp_code\images\image-20211103095214622.png)



## 4. How C++ compiler works

>  c++编译器唯一要做的就是把文本变为中继格式 `.obj`。
>
> 项目里的每个.cpp文件都会被编译成一个.obj，这些**`.cpp文件`**也叫做 **translation unity**（编译单元）。
>
> 即一个 **translation unity**会被编译器编译为一个 `object`文件

***<u>在c++中文件没有含义</u>***。比如 java要求class名必须与文件名相同，而且文件夹结构也得跟package一样。**但是c++没有文件这种东西，文件只是用来给编译器提供源码的某种方法。**编译器会自动根据文件类型处理文件，如.cpp、.c、.h。

> 在c++中一个cpp文件中include其他cpp文件是很常见的，本质上时将多个cpp文件组合成一个大的cpp文件里面包含了很多个文件。如果我们编译那一个大的cpp文件，也就是一个translation unity，则只会得到一个obj。
>
> 当且仅当我们的cpp文件中从不互相include的话，则一个cpp文件就是一个translation unity，每一个也会产生一个obj。

### 4.1 理解header文件用法的一个神奇的例子

1. 新建Math.cpp文件，并写入如下代码：

```c++
int Multiply(int a, int b)
{
	int result = a + b;
	return result;
#include "EndBrace.h"  //这一步就是简单粗暴的打开EndBrace.h，然后把里面的内容粘贴在当前文件中，即就能彻底理解header文件到底是怎么用的了。
```

2. 再新建EndBrace.h文件，添加如下内容：

```c++
}
```

3. 编译项目没有出错，也就证明了 include header文件就是直接将头文件复制粘贴到当前文件中。

### 4.2 另一个让编译器输出文档，里面包含preprocessor执行的结果

点击项目-->属性-->c++-->预处理器-->预处理到文件-->选择是-->应用

![image-20211103105029356](E:\newbie\cpp_code\images\image-20211103105029356.png)

重新编译当前文件得到`.i`文件。**此选项将取消编译，因此不会生成.obj文件。**

![image-20211103105242167](E:\newbie\cpp_code\images\image-20211103105242167.png)

```c++
#define INTEGER int  //查找前者用后者替换，不用加分号
```

![image-20211103110346229](E:\newbie\cpp_code\images\image-20211103110346229.png)

可以看到编译结果是一样的没有改变。

### 4.3 #if`if预处理语句可以让我们根据特定条件包含或者剔除代码

```c++
#if 1
int Multiply(int a, int b)
{
	int result = a + b;
	return result;
}
#endif
```

编译结果如下：

![image-20211103105242167](E:\newbie\cpp_code\images\image-20211103105242167.png)

```c++
#if 0
int Multiply(int a, int b)
{
	int result = a + b;
	return result;
}
#endif
```

编译结果如下：

![image-20211103111635420](E:\newbie\cpp_code\images\image-20211103111635420.png)

点击项目-->属性-->c++-->输出文件-->汇编程序输出-->仅有程序集的列表-->应用，就可以得到.obj文件的可读版本。

![image-20211103114643556](E:\newbie\cpp_code\images\image-20211103114643556.png)

可以看到有一个名为Multiply的代码段，这就是我们运行函数时cpu执行的真正指令。

![image-20211103115144873](E:\newbie\cpp_code\images\image-20211103114857146.png)

可以看到在63行将eax赋值给result，因为我们自定义了一个result变量，但是这个是非必要的。也就是说我们在写代码时要注意优化，不然底层就会有很大一部分时间在做无用功。

如下，去掉result，直接返回a和b的成绩，指令就简便了一些。

```c++
int Multiply(int a, int b)
{
	return a * b;
}
```

![image-20211103115358711](C:\Users\Melissa\AppData\Roaming\Typora\typora-user-images\image-20211103115358711.png)

这些代码看起来这么长是因为我们实在debug环境下进行编译的，而debug环境不进行任何优化，以确保代码尽可能冗长以及尽可能易于debug。

点击项目-->属性-->c++-->优化-->优化-->最大优化速度-->应用。

![image-20211103120005633](E:\newbie\cpp_code\images\image-20211103120005633.png)

![image-20211103120218718](E:\newbie\cpp_code\images\image-20211103120218718.png)

![image-20211103120339884](E:\newbie\cpp_code\images\image-20211103120339884.png)

设置优化后，代码缩减到47行。

![image-20211103120449735](E:\newbie\cpp_code\images\image-20211103120449735.png)

如果直接输入如下代码：

```c++
int Multiply()
{
	return 5 * 2;
}
```

真实指令也很简单，就是把10 mov到eax寄存器。而且还把把5*2简化成10，因为没有必要对两个常熟在运行时计算，这就是所谓的constant folding（常量折叠），任何之都会、可以在编译时计算出来。

![image-20211103120726720](E:\newbie\cpp_code\images\image-20211103120726720.png)

增加一个Log函数，并调用，看看其编译出来的结果。

```c++
const char* Log(const char* message)
{
	return message;
}

int Multiply(int a, int b)
{
	Log("Multiply");
	return a * b;
}
```

![image-20211103121330510](E:\newbie\cpp_code\images\image-20211103121330510.png)

调用函数时，编辑器就会产生一个call指令。

![image-20211103121547255](E:\newbie\cpp_code\images\image-20211103121547255.png)

## 5. How C++ linker works(HelloWorld2)

linking是从c++源码到可执行二进制时的一个过程。linking主要的工作是找到每个符号和函数的位置，并将它们链接在一起。

> 编译（`ctrl`+`F7`）只会编译，而生成（build`F5`）先编译然后链接。

- error的错误类型也提示了我们错误出现在什么阶段。比如，`C2143: 语法错误`中**C**开头表示错误发生在**编译**阶段，`LNK1561: entry point must be defined`中**LNK**开头表示错误发生在**linking**阶段。
- 如果生成对象是.exe文件时，则必须有一个entry point。

### 5.1 函数名的重要性

例如，有如下Log.cpp文件专门存放和日志相关的代码。

```c++
#include <iostream>

void Log(const char* message)
{
	std::cout << message << std::endl;
}
```

Math.cpp专门执行计算。

```c++
#include <iostream>

void Log(const char* message);

int Multiply(int a, int b)
{
	Log("Multiply");
	return a * b;
}

int main() 
{
	//std::cout << Multiply(5, 8) << std::endl;
	std::cin.get();
}
```

但是当我们不小心写错了Log.cpp文件中的Log，写成了Logr，单独编译Math.cpp是不会报错的。因为我们在Math.cpp中声明告诉主函数保证会有名为Log的函数存在的，至于函数到底存不存在不是编译过程要考虑的。

然后当我们生成项目时，报错提示linker无法解析外部符号Log，它在Multiply中被调用。

![image-20211103150615814](E:\newbie\cpp_code\images\image-20211103150615814.png)

- **如果注释掉上面的第7行，生成项目不会报错的，相当于没有调用过Log。**

- **但是，如果保留第7行注释13行，还会报同样的错误。这是因为我们虽然没有在当前文件中调用Multiply也即没有调用Log，但是有可能在其他文件中调用，因此linker也需要去链接它。**

- 除非在注释13行的同时告诉linker，Multiply只在当前文件中使用，linker也就不用去链接它。该方法就是给Multiply方法加上**`static`**的修饰词，即**静态变量函数**。

  ```c++
  #include <iostream>
  
  void Log(const char* message);
  
  static int Multiply(int a, int b)
  {
  	Log("Multiply");
  	return a * b;
  }
  
  int main() 
  {
  	//std::cout << Multiply(5, 8) << std::endl;
  	std::cin.get();
  }
  ```

### 5.2 返回类型的重要性

如果把Log.cpp中Log的返回类型改成int，则同样无法linking，因为linker会去寻找一个名为Log、且返回为void的函数。

```c++
#include <iostream>

int Log(const char* message)
{
	std::cout << message << std::endl;
	return 0;
}
```

![image-20211103153728984](E:\newbie\cpp_code\images\image-20211103153728984.png)

### 5.3 参数的重要性

如果给Log.cpp中Log的参数增加一个int类型level，则同样无法linking，因为linker会去寻找一个名为Log、且返回为void、同时只接受一个char为输入参数的函数。

```c++
#include <iostream>

int Log(const char* message, int level)
{
	std::cout << message << std::endl;
	return 0;
}
```

![image-20211103153728984](E:\newbie\cpp_code\images\image-20211103153728984.png)

---

### 5.4 小结

**以上三部分说明了，在连接过程中，函数名、返回类型、参数个数类型三个重要元素缺一不可，都必须被严格满足。**不要求的是，<u>定义和声明中参数的名称可以不同</u>。

当有两个函数的上述三部分都完全相同，linker也会报错。因为linker不知道该链接哪个。这种情况在同一个文件中发生我们是很容易察觉的，但通常这种问题会出现在不同的文件中，就不容易发现了。

例如Log.cpp文件如下，一眼就能看出错误。

```c++
#include <iostream>

void Log(const char* message)
{
	std::cout << message << std::endl;
}

void Log(const char* message)
{
	std::cout << message << std::endl;
}
```

我们执意去编译就会出现如下错。

![image-20211103155204723](E:\newbie\cpp_code\images\image-20211103155204723.png)

但如果在Log.cpp和Main.cpp中分别包含有一个完全一样的Log函数，这就会报出一个linking error，提醒我们Log被重复定义了，而且linker不知道应该链接哪个？

Log.cpp

```c++
#include <iostream>

void Log(const char* message)
{
	std::cout << message << std::endl;
}
```

Math.cpp

```c++
#include <iostream>

void Log(const char* message);

void Log(const char* message)
{
	std::cout << message << std::endl;
}

int Multiply(int a, int b)
{
	Log("Multiply");
	return a * b;
}

int main() 
{
	//std::cout << Multiply(5, 8) << std::endl;
	std::cin.get();
}
```

![image-20211103155901026](E:\newbie\cpp_code\images\image-20211103155901026.png)

### 5.5 linker报出重复定义的较难识别的场景

这种问题出现的频率比我们想象的要高，以下举几个会出现这种情况的例子

先定义一个Log.h，

```c++
#pragma once

void Log(const char* message)
{
	std::cout << message << std::endl;
}
```

然后在Logc.cpp中导入Log.h，

```c++
#include <iostream>
#include "Log.h"

void InitLog()
{
	Log("Initialized Log");
}
```

最后在Math.cpp中导入Log.h，

```c++
#include <iostream>
#include "Log.h"

void Log(const char* message);

int Multiply(int a, int b)
{
	Log("Multiply");
	return a * b;
}

int main() 
{
	//std::cout << Multiply(5, 8) << std::endl;
	std::cin.get();
}
```

编译过程正常不报错，生成过程就会报重复定义Log函数的错。

---

**疑问：**

**我们明明只在`Log.h`中定义了一次Log函数，为什么还会报重复定义的错误呢？**

**分析：**

**这就涉及到了include的工作原理。include其实是将头文件中的代码赋值粘贴到当前文件中，那么当我们分别在`Log.cpp`和`Math.cpp`中分别include了`Log.h`也就相当于在这两个文件中分别定义了一次Log函数。**

**如何解决：**

1. 一种方法是，**我们在`Log.h`文件中把Log函数定义为`static`，也就是这个log函数在链接时只应发生在该文件内部。**也就是说当这个Log函数在Log.cpp中和Math.cpp中，只会对该文件内部有效。即Log.cpp中和Math.cpp这两个文件分别会持有个人版本的Log函数，而且他们对于其他的.obj文件时不可见的。

   Log.h内容如下：

   ```c++
   #pragma once
   
   static void Log(const char* message)
   {
   	std::cout << message << std::endl;
   }
   ```

2. 另一种方法是，**让Log函数变成`inline`，他的意思是把函数的身体拿过来取代调用。**

   ```c++
   #pragma once
   
   inline void Log(const char* message)
   {
   	std::cout << message << std::endl;
   }
   ```

   也就是说，如下的调用，

   ```c++
   void InitLog()
   {
   	Log("Initialized Log");
   }
   ```

   实际上会变成：

   ```c++
   void InitLog()
   {
       std::cout << "Initialized Log" << std::endl;
   }
   ```

3. 作者会采用的方法是把Log函数的定义移动到一个**translation unity**中。会出现上述问题是因为Log函数被包含在两个translation unity中。

   具体操作方法：把Log定义部分移动到Log.cpp中，然后再Log.h中只留下声明。三个文件内容分别如下：

   Log.h

   ```c++
   #pragma once
   
   void Log(const char* message);
   ```

   Logc.cpp

   ```c++
   #include <iostream>
   #include "Log.h"
   
   void Log(const char* message)
   {
   	std::cout << message << std::endl;
   }
   
   void InitLog()
   {
   	Log("Initialized Log");
   }
   ```

   Math.cpp

   ```c++
   #include <iostream>
   #include "Log.h"
   
   void Log(const char* message);
   
   int Multiply(int a, int b)
   {
   	Log("Multiply");
   	return a * b;
   }
   
   int main() 
   {
   	std::cout << Multiply(5, 8) << std::endl;
   	std::cin.get();
   }
   ```

   即Log函数的定义只出现在Log.cpp中，在Log.h和Math.cpp中都只是进行了声明调用。

## 6. Variables in C++(HelloWorld3)

C++中给定了一些原始数据类型，这些数据类型基本上构成了我们在程序中存储的任何类型的数据的基础，每种数据类型都有特定的目的，但是我们并不一定非要将它用于那个目的。

**在C++中，不同的变量类型之间的唯一区别就是大小。即这个变量占用多少内存**

| 数据类型 | 长度 | 注意|
| -------- | ---- | ---- |
| char     | 1 bytes |char通常用于存储字符，即50和'A'（其实也是数字，是它对应的ASCII码值）都可以|
| short | 2 bytes ||
| int   | 4 bytes ||
| long  | 4 bytes ||
| long long | 8 bytes ||
| float |4 bytes||
| double |8 bytes||
| long double |||
| bool |1 bytes|**虽然它本身只占一位（bits），但是寻址不能寻到每个bit，只能寻址到bytes。因此我们无法创建一个大小只有1 bit的变量类型。**|

### 6.1 char

如果我们给**char类型**赋值**数字65**，当**char类型传入cout是都会被当作字符对待**。

```c++
#include <iostream>

int main()
{
	char a = 'A';
	std::cout << a << std::endl;
	a = 65;
	std::cout << a << std::endl;
	std::cin.get();
}
```

### 6.2 short

同理，如果我们给**short类型**赋值**字符’A‘**，当**short类型传入cout是都会被当作数字对待**。

```c++
#include <iostream>

int main()
{
	short a = 'A';
	std::cout << a << std::endl;
	a = 65;
	std::cout << a << std::endl;
	std::cin.get();
}
```

### 6.3 float and double

如果想存一个浮点数，可以使用float和double，但是下面代码可以看出虽然我们定义的是float类型，但是实际存储的却是double类型。

![image-20211104113611576](E:\newbie\cpp_code\images\image-20211104113611576.png)

那么应该如何区分这两个类型呢？解决方法就是在float变量后面加上一个**`f`**或者**`F`**。

![image-20211104113948925](E:\newbie\cpp_code\images\image-20211104113948925.png)

### 6.4 bool

0表示false，其他任何数字都表示true，即给bool类型变量赋任何除0以外的值，cout打印出来的都是1。

![image-20211104114500462](E:\newbie\cpp_code\images\image-20211104114500462.png)

**虽然它本身只占一位（bits），但是寻址不能寻到每个bit，只能寻址到bytes。因此我们无法创建一个大小只有1 bit的变量类型。**

> 一种高级的用法是把8个bool组成一个byte，即每一个bool本身还是只占一个bit。

### 6.5 sizeof

用来获取变量的字节数

```c++
#include <iostream>

int main()
{
	char a = 5;
	std::cout << sizeof(a) << std::endl;
	short b = 5;
	std::cout << sizeof(b) << std::endl;
	int c = 5;
	std::cout << sizeof(c) << std::endl;
	long d = 5;
	std::cout << sizeof(d) << std::endl;
	float e = 5.5f;
	std::cout << sizeof(e) << std::endl;
	double f = 5.5;
	std::cout << sizeof(f) << std::endl;
	bool g = 5;
	std::cout << sizeof(g) << std::endl;
}
```

打印 1 2 4 4 4 8 1。

### 6.6 其他类型

**指针**：在类型旁边加上一个`*`。

**引用**：在类型旁边加上一个`&`。

## 7. Functions in C++

函数是编写的代码块，被设计用来执行某个特定的任务。后面讲到class时，那些代码块被称为methods，Functions之的书某种不属于某个class的东西。

> 分离出函数，很大程度上是为了**防止代码重复**。

比如分离惩罚逻辑过程。多次调用Multiply方法并打印结果

```c++
#include <iostream>

int Multiply(int a, int b)
{
	return a * b;
}

int main()
{
	int result = Multiply(3, 2);
	std::cout << result << std::endl;
	int result2 = Multiply(8, 5);
	std::cout << result2 << std::endl;
	int result3 = Multiply(90, 45);
	std::cout << result3 << std::endl;

	std::cout << "HelloWorld" << std::endl;
	std::cin.get();
}
```

可以看出调用方法和打印语句同样被书写了很多次，因此也可以封装程一个函数MultiplyAndLog。

```c++
#include <iostream>

int Multiply(int a, int b)
{
	return a * b;
}

void MultiplyAndLog(int a, int b)
{
	int result = Multiply(a, b);
	std::cout << result << std::endl;
}


int main()
{
	MultiplyAndLog(3, 2);
	MultiplyAndLog(8, 5);
	MultiplyAndLog(90, 45);

	std::cout << "HelloWorld" << std::endl;
	std::cin.get();
}
```

我们应该把代码拆分成许多函数。但是也不能太过，因为那样会导致代码更慢，每当我们调用一次函数，编辑器就会产生一个call命令，也就是说程序运行中为了调用函数，我们需要为这个函数创建一整个stack frame（栈框架），也就是说我们得把参数之类的东西堆入栈中，还需要把一个返回地址的东西放到栈中，然后跳到程序的某个不同部分，一执行函数里的指令，再把结果push，因为需要返回给调用函数之前的地方。这里指令在内存中跳来跳去都要消耗时间。**但是这些是建立在便一九七决定保留函数作为函数，而不是内联（inline）它。**

- 函数如果定义必须返回某个类型的值，则最后必须返回这个值。

  ![image-20211104162801530](E:\newbie\cpp_code\images\image-20211104162801530.png)

- 有趣的是这一设定只在DEBUG模式下报错，在Release模式下编译不会报错。

  ![image-20211104162707318](E:\newbie\cpp_code\images\image-20211104162707318.png)

  但是如果我们实际那这个返回值去做处理的话，会得到未定义行为报错。

函数会被拆分为定义和声明，声明通常会存在head file中，而定义会写在translation unity里。

## 8. C++ header files

在C++基础中，头文件传统上是用来声明某些函数类型，以便于可以用于整个程序中。有声明这部分是为了让程序知道有这么个函数存在，比如我们在一个文件中创建函数，然后想要在另一个文件中使用，当我们尝试编译那个文件时C++肾实质都不会知道那个函数的存在，所以我们需要一个共同的地方来存放生命，而非定义（函数只能被定义一次）。

Log.cpp

```c++
void Log(const char* message);  //声明有这个函数存在

void InitLog()
{
	Log("Initializing Log");
}
```

Main.cpp

```c++
#include <iostream>

void Log(const char* message)
{
	std::cout << message << std::endl;
}


int main()
{
	Log("HelloWorld");
	std::cin.get();
}
```

上述示例中，通过声明`void Log(const char* message)`告诉程序有这个函数，项目可以生成。

但是如果我想在其他文件中也调用这个函数呢？是需要把这个声明到处复制粘贴吗？

这里给出一个简单的方法，**头文件！！！！！！！！！**

头文件的原理就是复制粘贴头文件中的代码到include的文件中。修改代码如下：

Log.h

```c++
#pragma once

void Log(const char* message);
```

log.cpp

```c++
#include <iostream>
#include "Log.h"

void Log(const char* message);

void InitLog()
{
	Log("Initializing Log");
}
```

Main.cpp

```c++
#include <iostream>
#include "Log.h"  //虽然在当前文件中已经包含了Log函数的定义，但是复制粘贴Log的声明也是不会报错

void Log(const char* message)
{
	std::cout << message << std::endl;
}

int main()
{
	Log("HelloWorld");
	std::cin.get();
}
```

### #pragma once（推荐）

每个头文件在编译之前被C++预处理器计算，pragma其实是一个被输入到编辑器或者预处理器的指令，告诉他们只include这个文件一次。

**`pragma once`**被称作**头文件保护符**`header guard`，它的功能是**防止我们把单个头文件多次include到一个single translation unity中**。注意他不能防止我们把头文件到处include，只是防止在单一翻译单元中多次include。

比较好的方法来示意这种情况是在头文件中创建一个struct，并注释掉pragma once

Log.h

```c++
//#pragma once

void Log(const char* message);
void InitLog();

struct Player {};
```

log.cpp

```c++
#include <iostream>
#include "Log.h"
#include "Log.h"  //重复include Log.h

void Log(const char* message)
{
	std::cout << message << std::endl;
}

void InitLog()
{
	Log("Initializing Log");
}

```

Main.cpp

```c++
#include <iostream>
#include "Log.h"

int main()
{
	Log("HelloWorld");
	std::cin.get();
}
```

就会产生如此下错误

![image-20211104173857500](E:\newbie\cpp_code\images\image-20211104173857500.png)

这里的错误就显而易见了。但实际情况往往更复杂，比如我们创建一个`Common.h` include了`Log.h`，然后在Log.cpp中分别include 这两个头文件，同样注释`Log.h`中的`#pragma once`.

Common.h

```c++
#pragma once

#include "Log.h"
```

Log.h

```c++
//#pragma once

void Log(const char* message);
void InitLog();

struct Player {};
```

Log.cpp

```c++
#include <iostream>
#include "Common.h"
#include "Log.h"

void Log(const char* message)
{
	std::cout << message << std::endl;
}

void InitLog()
{
	Log("Initializing Log");
}
```

同样会报“struct”类型重定义的错误。取消注释`#pragma once`代码就能正常生了。

### #ifndef

与`#pragma once`作用基本相同，它的功能是先检查`_LOG_H`是否存在，如果没有被定义，把结构体中的代码include 到编译里；如果被定义了则下面的代码都不会被include，会全部被禁用。

Log.h

```c++
#ifndef _LOG_H
#define _LOG_H

void Log(const char* message);
void InitLog();

struct Player {};
#endif
```

### include<> 和 include ""

当我们编译时有两种方式告诉编译器include的路径，分别是绝对路径和相对路径。

- **`include <>`**即绝对路径，是让编译器在所有**include路径（需要进行设置的）**里去搜索这个文件。

- **`include ""`**即相对路径，用于include文件存在于当前文件的相对位置的情况。

也就是说尖括号只用于编译器里的include路径，而双引号可以用于所有情况。

**注意：**

`#include <iostream>`中，iostream是没有后缀的看起来不像一个文件，这是写标准库的人设计的用于区分C标准库和C++标准库

- C标准库：有.h后缀
- C++标准库：没有后缀



## 9. How to debug C++ in VS

- 断点
- 查看内存

只有在debug模式下加断点才是有意义的。

计算器-->三杠-->程序员-->就能计算2、8、10、16进制

查看内存：

![20211104182423](E:\newbie\cpp_code\images\image-20211104182423.jpg)

通过`&`+变量名就能查询到变量的内存地址。

## 10. Conditions and branches in C++(if statements)

if 语句和if-else语句

当我们跑代码时，会有对实际条件情况的比较，还有取决于比较结果的分支。

>  if 语句分支实际上就是比较条件、跳转到内存中的其他部分然后执行指令，意味着，如果我们的语句和分支分布在内存距离较远的地方，并且当我们打算写一些搞笑的代码是，就有可能不去使用if语句。实际上很多优化过的代码会尤其避免分支结构，避免比较，因为那么做会让代码变慢。

> 本节最后我们会看一些将分支结构去除的优化示例。

![image-20211105094532915](E:\newbie\cpp_code\images\image-20211105094532915.png)

![image-20211105094717793](E:\newbie\cpp_code\images\image-20211105094717793.png)

没有所谓的else if整体实际上是把else{ if{}}写到了一行中，如下两个代码块含义相同：

```c++
int main()
{
	int x = 6;
	if (x)
    {
        std::cout << "HelloWorld" << std::endl;
    }
	else if (x == 5)  //只有当if失败的情况下才会去执行else后面的代码
    {
        std::cout << "Unequal" << std::endl;
    }
	std::cin.get();
}
```

```c++
int main()
{
	int x = 6;
	if (x)
    {
        std::cout << "HelloWorld" << std::endl;
    }
	else
    {
        if (x == 5)
        {
            std::cout << "Unequal" << std::endl;
        }
    }
	std::cin.get();
}
```

作者认为编程可以分为数学编程和逻辑编程两大部分。

## 【Extra】Best VS setup for C++ projects

在VS中创建一个新的空项目，观察创建好的项目文件夹，`.vcxproj`是我们创建的项目文件，本质上是一个xml。

![image-20211105101854686](E:\newbie\cpp_code\images\image-20211105101854686.png)

这几个看起来像文件夹的实际不是文件夹，而是过滤器，比如右键项目进行添加，发现没有添加文件夹，只有添加过滤器。过滤器是以这种虚拟文件夹的形式工作，过滤器视图中文件可以随意放置，与实际的文件夹并无关系，只是一个用来将东西分类的界面。

![image-20211105102250867](E:\newbie\cpp_code\images\image-20211105102250867.png)

在这种视图中源文件过滤器中创建的文件在实际文件夹中会和项目文件放在一起比较混乱。

![image-20211105102721064](E:\newbie\cpp_code\images\image-20211105102721064.png)

如果我们想单独创建一个source的文件夹来存放所有的源代码以区分与项目代码，就需要切换项目视图

![image-20211105102934635](E:\newbie\cpp_code\images\image-20211105102934635.png)

这就能看到真实的项目文件夹了，右键项目添加，就可以新建文件夹

![image-20211105103114052](E:\newbie\cpp_code\images\image-20211105103114052.png)

在Debug模式（默认设置）下生成项目，会把中间文件放在项目目录下的Debug文件中，把实际可运行的ese文件放在和sln文件一起的那个Debug目录下。如此设计有一定非人性，我们需要自行配置：

![image-20211105104546874](E:\newbie\cpp_code\images\image-20211105104546874.png)

如果不了解$符号后这些宏表示什么意思，可以通过下拉三角<编辑>去查看宏，

![image-20211105105041763](E:\newbie\cpp_code\images\image-20211105105041763.png)

## 11. Loops in C++ (for loops, while loops)

### 11.1. for loops

```c++
#include <iostream>
#include "Log.h"

int main()
{
	for (int i = 0; i < 5; i++)
	{
		Log("HelloWorld");
	}
	std::cin.get();
}
```

for (初始条件; 结束条件; 执行的语句)

其中，初始条件在for循环开始前执行一次，执行语句是每次迭代结束后都要执行的语句，结束条件是执行完循环体和执行语句后进行的比较。

```c++
#include <iostream>
#include "Log.h"

int main()
{
	int i = 0;
	bool condition = true;
	for ( ; condition; )
	{
		Log("HelloWorld");
		std::cout << i << std::endl;
		i++;
		if (!(i < 5))
			condition = false;
	}
}
```

上面示例说明了for loop各部分执行的顺序：

1. 初始条件
2. 条件判断
3. 循环体
4. 执行语句

如果条件判断结果为true，则循环执行3、4，否则结束循环

### 11.2. while loops

```c++
#include <iostream>
#include "Log.h"

int main()
{
	int i = 0;
	while (i < 5)
	{
		Log("HelloWorld");
		std::cout << i << std::endl;
		i++;
	}
    std::cin.get();
}
```

### 11.3. 小结

具体选择for loops还是while loops其实主要取决于是否需要新的变量。

如果条件判断已经有一个变量的情况下，通常使用while loops，因为它只需要提供条件，而不用每次循环都改变条件。循环前也不用声明变量，因为条件布尔值已经声明好了，可以直接使用while就好了。不需要使用前声明变量或每次更新值。

而遍历数组时，数组大小确定，推荐使用for loops，因为一样的代码跑十遍的时候，需要10遍中有变量，而且该变量在访问数组的时候有用时

### 11.4. do while loops

```c++
bool condition = false;
do
{
	Log("HelloWorld");
} while (condition);
```

它与while loops的唯一区别就是它的循环体至少会被执行一次。

## 12. Control flow in C++(continue, break, return)

- `continue`：如果还能进行迭代的话直接进行下一次的迭代，否则结束循环。

```c++
#include <iostream>
#include "Log.h"

int main()
{
	for (int i = 0; i < 5; i++)
	{
		if (i > 2)
		{
			continue;
		}
		Log("HelloWorld");
		std::cout << i << std::endl;
	}
	std::cin.get();
}
```

- `break`：直接跳出循环。

```c++
#include <iostream>
#include "Log.h"

int main()
{
	for (int i = 0; i < 5; i++)
	{
		if (i > 2)
		{
			break;;
		}
		Log("HelloWorld");
		std::cout << i << std::endl;
	}
	std::cin.get();
}
```

- `return`：直接完全地退出函数。如果返回类型时void，则只需要return就行；如果函数需要返回值，在输入return时就必须要提供值。return不用像break和continue那样在循环中使用，return可以在代码的任何地方。



## 13. Pointers（raw pointer）

### 13.1. Pointer的本质

**pointer是一个数字，一个整数，它存储一个内存地址。**把内存想象成一条街，一条一维的线型的街，街上有很多房子，每个房子都有地址，每一个带地址的房子都可以想象成一个byte，它是一个字节的数据。我们需要一个方法去给所有字节取址，比如有人从网上买了东西，并且要送货上门，就必须要有房子的地址。

pointer本身是没有类型的，而我们规定的类型最直观的理解可能是它所指向的地址中的数据可能的类型。

```c++
void* ptr = 0;  //赋值为0，是表示这个指针式无效的，也就是它不是一个有效的内存地址。
```

也可以写作

```c++
void* ptr = NULL; 
```

NULL的含义也是#define 0

![image-20211105141923136](E:\newbie\cpp_code\images\image-20211105141923136.png)

或者赋值为c++的一个关键字nullptr

```c++
void* ptr = nullptr;  //这是在c++11中引入的
```

### 13.2. `&`取址符

`&`取址符

```c++
int var = 8;
void* ptr = &var;  //在变量前加上取址符，实际上是在获取它的内存地址，然后把拿到的变量的内存地址把它赋给一个叫ptr的新变量
```

在内存中查看这个地址：

![image-20211105142758150](E:\newbie\cpp_code\images\image-20211105142758150.png)

### 13.3. `*`寻址符

当我们拿到了内存的地址之后该如何去访问地址中的内容呢？

在指针变量前假`*`，如下：

```c++
int var = 8;
void* ptr = &var;  //&+变量名获取变量的内存地址

*ptr  //*+指针获取指针指向内存地址的内容
```

我们可以向指针指向的内存中读取或者写入，如下图所示，给ptr指向的内存中存入10，但是意外的报错了，这是因为我们给定的指针ptr的类型是void，计算机怎么能把一个值写到一个void指针里去呢？

即如果是void指针，计算机不知道这个指针指的内存是几个字节，也就没办法像这个内存中存入那种数据类型。也就是说我们在使用指针时需要告诉指针它指向的是什么类型。

![image-20211105174724132](E:\newbie\cpp_code\images\image-20211105174724132.png)

```c++
#include <iostream>

#define LOG(x) std::cout << x << std::endl;

int main()
{
	int var = 8;
	int* ptr = &var;  //赋值为0，是表示这个指针式无效的，也就是它不是一个有效的内存地址。
	*ptr = 10;
	LOG(var);
	std::cin.get();
}
```

### 13.4.让内存为我们分配特定大小

目前我们创建变量的方法是在内存的stack中创建变量，内存分为stack和heap，两者的区别后面会详细讲到。另一个方法是我们可以在heap中创建变量。

为了让内存为我们分配特定大小就可以使用char*，因为我们清楚char占用一个字节。如下：

```c++
char* buffer = new char[8];
```

上述代码实际做的事是为我们分配了8个字节的内存，并返回一个指向这块内存的开始地址的指针。

然后在使用`memset`函数来用指定的数据去填充一块内存，它接受一个指针，指向内存快的开始处，一个值，比如0，然后是大小即填充几个字节，用法如下：

```c++
#include <iostream>

#define LOG(x) std::cout << x << std::endl;

int main()
{
	char* buffer = new char[8];
	memset(buffer, 0, 8);
    
    delete[] buffer;

	std::cin.get();
}
```

我们使用到了new这个关键字，它指定的数据是分配在heap上的，我们还需要在处理完后删除这个数据。new和delete都是在heap上操作内存，最后还可以用`buffer = nullptr;`来回收指针。

> 要强调的一点是，指针本身也只是变量，这些变量也存储在内存之中。
>
> 如下我们创建一个二级指针，然后来查看内存
>
> ```c++
> #include <iostream>
> 
> #define LOG(x) std::cout << x << std::endl;
> 
> int main()
> {
> 	char* buffer = new char[8];
> 	memset(buffer, 0, 8);
> 
> 	char** ptr = &buffer;  //指针的指针
> 
> 	delete[] buffer;
> 	std::cin.get();
> }
> ```
>
> 下图中二级指针指向的是一级指针所在的地址，可以看到这个地址的存法是高位到低位倒序存储的，重新倒序组合起来就是一级指针实际指向的地址。
>
> ![image-20211105183450479](E:\newbie\cpp_code\images\image-20211105183450479.png)



## 14. Reference

### 14.1 简单的引用

事实上reference只是指针的一个扩展，但是在使用上还是有一些差别，最终引用只是指针的语法糖，是指针更易读。

对于指针，我们可以创建一个新的指针并赋予nullptr，而引用不行，引用变量必须引用一个已经存在的变量，这个变量本身并不是一个新的变量。

```c++
#include <iostream>

int main()
{
	int a = 5;
	//int* ptr = &a;  //ptr存的是a的地址
	int& ref = a;  //ref实际上只是a的一个别名，和指向同一个地址
	std::cin.get();
}
```

在编译过程中，并不会创建两个变量a和引用变量ref，而是只有一个变量啊，但是我们却可以把ref昂做a来用。

这种情况下，引用并不是一个指针，编译器没有必要创建一个新的变量。

### 14.2. 复杂的引用

```c++
#include <iostream>

#define LOG(x) std::cout << x << std::endl;

void Increment(int value)
{
	value++;
}

int main()
{
	int a = 5;
	Increment(a);  //这里是传值调用，不是引用或者指针
	LOG(a);

	std::cin.get();
}
```

**传值调用**，调用过程中程序将会拷贝参数值5到这个函数里，直接拷贝将会创造一个全新的变量value。因为上述Increment方法相当于只处理的value变量，而不改变a。

通常我们会获取函数返回的值赋给一个变量，来获取函数处理过的而变量，如果我们想通过上述返回void的函数来影响a的值，就需要使用**引用传递**。

聪明的方法就是我们不传a这个之本身给函数，而是把a的内存地址传给函数，操作如下：

```c++
#include <iostream>

#define LOG(x) std::cout << x << std::endl;

void Increment(int* value)
{
	(*value)++;  //*解引用回去对应内存地址中的值
}

int main()
{
	int a = 5;
	Increment(&a);  //&获取a的地址传给函数
	LOG(a);

	std::cin.get();
}
```

注意`*value++;`是给代表内存地址的value增1而不是实际的值。因为操作符的优先级递增符号会优先执行，所以需要给*和value加一个括号`(*value)++`。

其实还有一个更简便的方法，如下：

```c++
#include <iostream>

#define LOG(x) std::cout << x << std::endl;

void Increment(int& value)  //把指针改成引用的形式
{
	value++;
}

int main()
{
	int a = 5;
	Increment(a);  //传入的参数依旧是a
	LOG(a);

	std::cin.get();
}
```

相当于传进去的还是a，但是函数获取的并不是复制出来的a的值，而是a的引用--value。

引用能做的指针都能做，指针比起引用更强大一点。

**但是在上述的情况下，建议使用引用，代码会更简洁可读性更高，而且引用会让源码看起来干净很多。**

**注意：**

 -  **一旦声明了一个引用，就不能更改它所引用的对象。**

    ```c++
    #include <iostream>
    
    #define LOG(x) std::cout << x << std::endl;
    
    void Increment(int& value)  //把指针改成引用的形式
    {
    	value++;
    }
    
    int main()
    {
    	int a = 5;
        int b = 8:
        
        int& ref = a;
        ref = b;  //这里的操作并不是让ref引用b，而是直接把b的值赋给ref引用的对象，也就是a，那么a也会等于8
        
    	Increment(a);
    	LOG(a);
    
    	std::cin.get();
    }
    ```

- 当声明一个引用时，必须将一个实际的变量赋值给它。

  ```c++
  int& ref;  //这种写法是不允许的
  ```

### 如果我们确实想改变ref所代指的对象该怎么办呢？

我们需要创建一些变量使它先指向a，然后再让它指向b。仔细分析一下这句话，使用指针就可以实现这个目的。***<u>？？？？？？？？？？？？？？？？？？？？？？？？</u>***

```c++
#include <iostream>

#define LOG(x) std::cout << x << std::endl;

int main()
{
	int a = 5;
    int b = 8:
    
    int* ref = &a;
    *ref = 2;
    ref = &b;
    *ref = 0;
    
    LOG(a);
	LOG(b);

	std::cin.get();
}
```



## 15. Classes in C++

JAVA、C#本质上也是面向对象的语言，对于这两种语言来说最好不要编写其他风格的程序，总的来说这两种语言只适合面向对象编程。

然而C++不同的地方在于它不仅仅支持面向对象变成，事实上C++支持面向过程、基于对象、面向对象、泛型编程四种。

### 15.1. 类的本质

类本质上是一种将数据和函数组织在一起的方式。

**当创建一个类时，可以指定类中属性的可见性。默认情况下，类中的成员的访问控制都是私有的，意味着只有类内部的函数可以访问这些变量。**

```c++
#include <iostream>

#define LOG(x) std::cout << x << std::endl;

class Player  //定义一个玩家类
{
public:  //指定下面变量能够从类外访问
	int x, y;  //包含玩家坐标
	int speed = 2;  //玩家移动速度
};

int main()
{
	Player player;
	player.x = 5;

	std::cin.get();
}
```

添加一个移动玩家位置的方法：

```c++
#include <iostream>

#define LOG(x) std::cout << x << std::endl;

class Player
{
public:
	int x, y;
	int speed = 2;

	void Move(int xa, int ya)
	{
		x = xa * speed;
		y = ya * speed;
	}
};

int main()
{
	Player player;
	player.Move(1, -1);

	std::cin.get();
}
```

### 15.2. Classes vs Structs in C++

结构体和类一样都是将数据和函数组织在一起，唯一的区别是**类默认所有内容都是私有的，而结构体默认都是共有的。**

C++中结构体存在的唯一原因是它想要维持与C之间的兼容性，因为C中没有类，但是它含有结构体，如果突然完全删去struct这个关键字，那就会失去所有兼容性。因为C++的编辑器不知道什么是struct，但是我们可以通过`#define`来解决这个问题，`#define struct class`这会将所有的struct替换为class。

那么既然这两个关键字没有本质的区别，那我们在使用中会有区别吗？

结果当然是没有的，但是由多年开发经验总结，struct推荐仅仅用来表示一堆变量，它的意义相当于数学中的向量类，如下从根本上说这个Vec2 struct只是两个浮点数的表现形式，我们只是把他们按字面意义上组合起来为了便于使用。

```c++
struct Vec2
{
    float x, y;
}
```

但是这不意味着我们不打算向里面添加方法，如下面我们只是添加了一个函数来操作这些变量，Add方法将两个Vec2向量加起来，但是最终我们讨论的还是这两个变量。

```c++
struct Vec2
{
    float x, y;
    
    void Add(const Vec2& other)
    {
        x += other.x;
        y += other.y;
    }
}
```

另一个要注意的地方是继承，不建议对struct进行继承，如果我们要用一个完整的类层次或某种继承层次建议使用class。因为继承又增加了一层复杂性，而我们想让struct仅仅是数据的结构体。

如果我们由一个类A，一个结构体B它继承自A，一些编译器会发出警告，警告你正在从一个类继承但是你本身只是一个结构体，但这只是警告代码照样可以运行。



## 16. How to write a C++ class

写一个简单的Log Class，以及一个高级一点的改进版本。

日志类是给我们管理log信息的一个方式，换句话说就是我们想要程序打印到控制台的消息或信息，这通常用于调试目的，它可以真正帮助我们在开发中查看具体进度。因为我们应用程序中的控制台十几场就像一个信息转储，我们可以使用它来打印正在发生的事情，控制台基本是内嵌在操作系统中的东西，我们可以保证它一定能正常运作。

作者在这里使用Log类作为示例，是因为Log系统可以根据的需要变得简单或复杂。Log系统不仅可以打印到控制台，还可以打印不同颜色、将log信息输出到一个文件或者网络……。

我们这里要写的是一个包含log等级的简单Log类，等级分为error、warning、message or trace。

如下：

```c++
#include <iostream>

class Log
{
public:
	const int LogLevelError = 0;
	const int LogLevelWarning = 1;
	const int LogLevelInfo = 2;
private:
	int m_LogLevel = LogLevelInfo;
public:
	void SetLevel(int level)
	{
		m_LogLevel = level;
	}

	void Error(const char* massage)
	{
		if (m_LogLevel >= LogLevelError)
			std::cout << "[ERROR]: " << massage << std::endl;
	}

	void Warn(const char* massage)
	{
		if (m_LogLevel >= LogLevelWarning)
			std::cout << "[WARNING]: " << massage << std::endl;
	}

	void Info(const char* massage)
	{
		if (m_LogLevel >= LogLevelInfo)
			std::cout << "[INFO]: " << massage << std::endl;
	}
};

int main()
{
	Log log;
	log.SetLevel(log.LogLevelError);
	log.Error("Hello");
	log.Warn("Hello");
	log.Info("Hello");
	std::cin.get();
}
```

上面代码中第10行，这里m_是约定好的，它表示这是一个私有的类成员变量，这样在函数内部写代码时就能够区分那些类作用于的一部分、哪些是成员变量、哪些是局部变量。

上述的代码只是一个最简单的Log类，但他并不是一个比较好的代码，只是比较简单易于理解。但是这提供了我们优化这个类的理由，后续会对上面代码进行优化，给出改进写法并说明为什么这么改。



## 17. Static in C++

C++中static实际上有两个含义取决于使用关键字时的上下文，其中一种是在一个类或者一个结构体之外使用，另一种是在类或结构体内部使用。基本上，类外部的static修饰意味着你的声明在link阶段是局部的，也就是它只对定义它的translation unity（.obj）是可见的。而类或结构体中的静态变量，意味着这部分内存实际上是这个类的所有实例共享的，也就是说，即使实例化了很多次这个类或结构体，那个静态变量也只有一个实例。类里面的静态方法也一样，静态方法里没有该实例的指针（this）。

### 17.1. 类或结构体外的static

这节讨论类或结构体外的static。下面的static关键字表示这个变量在link的时候只对这个编译单元（.obj）里的东西可见。

Stasic.cpp

```c++
static int s_Variable = 5;
```

Main.cpp

```c++
#include <iostream>

int s_Variable = 10;

int main()
{
	std::cout << s_Variable << std::endl;
	std::cin.get();
}
```

直接编译执行项目，发现不报错并打印出10。但如果去掉Static.cpp中的static关键字，就会报出link error。也就是说我们不能有两个一样名字一样的全局变量。![image-20211109105639433](E:\newbie\cpp_code\images\image-20211109105639433.png)

一种解决方法是去掉Main.cpp中的赋值，并加上extern关键字，他就会在另外的编译单元中找定义。这特叫做外部链接。如下会打印出5。

Main.cpp

```c++
#include <iostream>

extern int s_Variable;

int main()
{
	std::cout << s_Variable << std::endl;
	std::cin.get();
}
```

但是如果这时我们给Stasic.cpp里的s_Variable加上static关键字，也就意味着我们定义了一个当前文件中的私有变量，其他的编译单元不能访问s_Variable，linker在全局作用域下找不到它，就会报出未知外部符号的link error。

![image-20211109110427391](E:\newbie\cpp_code\images\image-20211109110427391.png)

对于函数是同样的。

我们使用static的时机与class的成员用private类似，基本上只要我们不想让变量时全局可见的，static想用多少就用多少，因为如果不带static关键字定义全局变量的话，就会发现linker在所有的二编译单元中都能检测到它，它是绝对全局的，也就可能导致奇奇怪怪的bug。

总而言之，尽可能让全局函数和变量变成静态的，除非我们必须要将他们用在其他的编译单元里。

### 17.2. 类或结构体内的static

通常面向对象的编程中，类或结构体内部的static，如果用在变量上意味着在所有的类的实例中只会有一个那个变量的实例。用这个类实例化的对象共享这一个static变量，也就是说如果我们在一个类实例中改变静态变量的值，那么就会改变所有类实例中的值，它就相当于这个类中的全局变量。

如果用在方法上也是类似的，类中静态方法没有访问实例的权限，静态方法可以在没有实例化的情况下调用，在静态方法之中也不能写代码去引用类实例，因为我们没有类实例来引用。

如下，正常打印出2, 3和5, 8

Main.cpp

```c++
#include <iostream>

struct Entity
{
	int x, y;

	void Print()
	{
		std::cout << x << ", " << y << std::endl;
	}
};

int main()

{
	Entity e;
	e.x = 2;
	e.y = 3;
	e.Print();
	Entity e1 = { 5, 8 };
	e1.Print();
	std::cin.get();
}
```

但是如果我们把第五行x和y替换成静态变量，则20行的实例化定义就会报错，是因为这是x和y就不再是class成员了。抛弃这一点和上面e同样的定义方法，

```c++
	static int x, y;
```

```c++
	Entity e1;
	e1.x = 5;  //这里赋值显然和e指向的是两个不同的实例
	e1.y = 8;
```

运行代码，就会报出如下错误，这是因为我们需要在其他地方定义这两个静态变量。

![image-20211109113438066](E:\newbie\cpp_code\images\image-20211109113438066.png)

```c++
#include <iostream>


struct Entity
{
	static int x, y;

	void Print()
	{
		std::cout << x << ", " << y << std::endl;
	}
};

int Entity::x;
int Entity::y;

int main()

{
	Entity e;
	e.x = 2;
	e.y = 3;
	e.Print();
	Entity e1;
	e1.x = 5;  //这里赋值显然指向的是两个不同的实例
	e1.y = 8;
	e1.Print();
	std::cin.get();
}
```

再次运行代码后发现，两次都打印出了5, 8。实际上当我们在类型中定义静态变量时，实际上不同实例中的相同变量这实际上指向的是同一块内存，因此子啊任何实例中修改这个静态变量都会直接修改同一块内存的内容，因此，对于静态变量可以通过类名.变量名的方式进行访问，并非一定要进行实例化。

```c++
	Entity::x = 5;  //这里赋值显然指向的是两个不同的实例
	Entity::y = 8;
```

其实相当于我们在Entity的命名空间下定义了两个变量x和y，它实际上不属于class，我们在实例化进行资源时与它并无关系。同意写法后就发现我们实际上修改的是同一个变量。

```c++
#include <iostream>


struct Entity
{
	static int x, y;

	void Print()
	{
		std::cout << x << ", " << y << std::endl;
	}
};

int Entity::x;
int Entity::y;

int main()

{
	Entity e;
	Entity::x = 2;
	Entity::y = 3;
	e.Print();
	Entity e1;
	Entity::x = 5;  //这里赋值显然指向的是两个不同的实例
	Entity::y = 8;
	e1.Print();
	std::cin.get();
}
```

同样的我们也可以定义一个全局变量，或者静态全局变量，它依旧会进行link只是不会在出现在整个项目中。上述处理与类中定义静态变量是一样的效果，那么把这些静态变量放入Entity是因为这么处理比较合理，如果我们有一块内存数据想要在所有实例中都共享，把它放在Entity类中就是比较合理的了，就是做局部通用的而变量而不是全局的静态变量。

对于静态方法一样的处理

```c++
#include <iostream>

struct Entity
{
	static int x, y;

	static void Print()
	{
		std::cout << x << ", " << y << std::endl;
	}
};

int Entity::x;
int Entity::y;

int main()

{
	Entity e;
	Entity::x = 2;
	Entity::y = 3;
	Entity::Print();
	Entity e1;
	Entity::x = 5;
	Entity::y = 8;
	Entity::Print();
	std::cin.get();
}
```

要注意的是静态方法不能直接访问非静态变量，除非通过实例。是因为静态方法本身不包含实例，这就涉及到类的工作原理，往深细究，根本没有class这么个东西，只是一个类中非静态的变量或方法都包含一个指向当前类的隐藏变量，而静态方法不能获取那个隐藏变量，它就相当于在类外定义一个相同的方法。也就是在调用Print方法是他不知道你所引用的Entity具体是哪个，也就会报错了。

### 17.3. Local static in C++

本地作用域中用static来声明变量，和前面两种用法有些不同，只要我们从声明变量时要考虑的两个点就能理解他们的区别了，这两点就是生命周期（life time）和作用域（scope）。

生命周期是指变量在被删除之前在内存中停留了多久；作用于就是我们能在哪里访问这个变量。

所以静态局部变量允许我们定义一个变量，它的**生命周期时整个程序周期**，但是**作用域被限制在这个函数（命名空间，也可以是if语句或者别的有作用域的地方）里**。静态函数一直放在使用的存储区，直到退出程序。

本地静态变量和类静态变量没有很大差别因为他们的生命周期是一样的，唯一的区别是类作用语中的静态变量可以被类作用域中的任何变量访问，当然我们在函数中声明的静态变量是对函数本地的。

```c++
void Function()
{
	static int i = 0;
}
```

上面的函数，我们第一次调用它时，静态变量的值被初始化为0，后续调用不会再创建一个新的变量。

通过如下方式进行验证，执行下面代码会打印出1 2 3。

```c++
#include <iostream>

void Function()
{
	static int i = 0;
	i++;
	std::cout << i << std::endl;
}

int main()
{
	Function();
	Function();
	Function();
	std::cin.get();
}
```

但如果我们去掉static，i每次都会被重新赋值0，因此就会打印出1 1 1。

```c++
#include <iostream>

void Function()
{
	int i = 0;
	i++;
	std::cout << i << std::endl;
}

int main()
{
	Function();
	Function();
	Function();
	std::cin.get();
}
```

Function内部的静态变量等价于把static int i = 0；的声明定义放在函数外

```c++
#include <iostream>

static int i = 0;

void Function()
{
	i++;
	std::cout << i << std::endl;
}

int main()
{
	Function();
	Function();
	Function();
	std::cin.get();
}
```

但是这种两种写法不一样的地方在于，后者可以在函数外其他地方也能访问到这个变量，如果不小心修改了静态变量的值就会出问题，如下代码会打印出1 11 12

```c++
#include <iostream>

static int i = 0;

void Function()
{
	i++;
	std::cout << i << std::endl;
}

int main()
{
	Function();
    i = 10;
	Function();
	Function();
	std::cin.get();
}
```

总的来说如果我们想要共享内存但是又不想要任何地方都能访问到这个变量时就可以定义为本地变量。

还有一种情况是如果我们有一个singleton类，即类只有一个实例，如果我想创建一个单体类而不创建局部静态变量，就是如下的做法，比较复杂。

```c++
#include <iostream>

class Singleton
{
private:
	static Singleton* s_Instance;  //因为是单体类，所以私有属性是一个指向类实体的指针

public:
	static Singleton& Get() { return *s_Instance; }  //这里返回的是单体类的实例

	void Hello() {}
};

Singleton* Singleton::s_Instance = nullptr;

int main()
{
	Singleton::Get().Hello();
	std::cin.get();
}
```

或者可以直接通过局部静态变量来简化单体类

```c++
#include <iostream>

class Singleton
{
public:
	static Singleton& Get()
	{ 
		static Singleton instance;
		return instance;
	}

	void Hello() {}
};

void Function()
{
	static int i = 0;
	i++;
	std::cout << i << std::endl;
}

int main()
{
	Singleton::Get().Hello();
	std::cin.get();
}
```

如下，如果我们没有把单体类的实例定义为静态变量，它会在遇到return之后的花括号的时候被销毁，然后函数结束。如果get方法的是结果的复制那没问题，它会将instance复制一份return回去。但如果像上面第六行中返回一个引用就会出现的问题是instance占用的内存已经被销毁了也就无法在使用了。也就是说static大大延长了实例的生命周期

```c++
class Singleton
{
public:
	Singleton& Get()
	{ 
		static Singleton instance;
		return instance;
	}

	void Hello() {}
};
```

## 18. Enums in C++

有事我们可能想使用一些变量为某个值的时候做相应的处理。如果我们直接简单定义整型变量A、B、C时他可能在全局中都是可访问的，如果一不小心修改了其中的值就有可能使某部分代码完全失去作用。因此，推荐使用enum类型，如下定义了一个枚举类型Example，需要分别定义枚举可取内容如A、B、C，在后续实例化并赋值的时候就只能设置为枚举数中的任意一个，而不能设置为集合外的其他值。

```c++
#include <iostream>

enum Example
{
	A, B, C
};

int main()
{
	Example value = A;
	Example value = 5;  //这里就会报错
	std::cin.get();
}
```

但是本质上来说，枚举数也是整形的集合，如果未做特殊设置，它里面元素的值会按照从前到后从0开始的编号，即上面第五行就意味着A=0、B=1、C=2。但是我们也可以给各个符号赋值的，如下，其实这里的A、B、C也只是一个表示的符号而已，具体值取决于我们付给它本身的值。

```c++
enum Example
{
	A = 3, B = 2, C = 5
};
```

还有一个要注意的地方是，我们不需要同时给所有符号赋值，比如下面我们只给A赋值为5，后面的B、C则会自动增加分别为6和7。

```c++
enum Example
{
	A = 5, B, C
};
```

除此之外我们还可以指定枚举的数据类型，设置为什么类型枚举数就占几个字节，当然如果枚举数比较少的话，也可以直接设为char只占用一个字节节省内存

```c++
enum Example : char
{
	A = 5, B, C
};
```

**注意：枚举的必须是整型，也就是不能设置为float等，因为它不是整型。**

回过头看16.里面我们写过的Log类中就是使用简单的罗列定义了三个log的等级，他们本质上就是整数，而且希望LogLevel只能被设置为这几个数，因此可以通过enum类型来进行优化。

![image-20211110165431461](E:\newbie\cpp_code\images\image-20211110165431461.png)

优化后如下：

```c++
#include <iostream>

class Log
{
public:
	enum Level
	{
		LevelError = 0, LevelWarning, LevelInfo  //希望从0开始递增
	};
private:
	Level m_LogLevel = LevelInfo;
public:
	void SetLevel(Level level)  //
	{
		m_LogLevel = level;
	}

	void Error(const char* massage)
	{
		if (m_LogLevel >= LevelError)
			std::cout << "[ERROR]: " << massage << std::endl;
	}

	void Warn(const char* massage)
	{
		if (m_LogLevel >= LevelWarning)
			std::cout << "[WARNING]: " << massage << std::endl;
	}

	void Info(const char* massage)
	{
		if (m_LogLevel >= LevelInfo)
			std::cout << "[INFO]: " << massage << std::endl;
	}
};

int main()
{
	Log log;
	log.SetLevel(Log::LevelError);  //虽然使用enum加了一层花括号，但是它并不是命名空间，变量本质上还是在Log命名空间中的
	log.Error("Hello");
	log.Warn("Hello");
	log.Info("Hello");
	std::cin.get();
}
```



## 19. Constructors in C++

构造函数是一个特殊类型的方法，在我们每次实例化一个类对象时都会被调用。

如下给出一个在创建类时没有使用构造函数的示例：

```c++
#include <iostream>

class Entity
{
public:
	float X, Y;

	void Print()
	{
		std::cout << "X=" << X << ",Y=" << Y << std::endl;
	}
};

int main()
{
	Entity e;
	e.Print();
	std::cin.get();
}
```

如果我们只进行实例化就直接调用Print方法，会得到如下结果，可以看到两个变量都有一个奇怪的值，这个结果是因为我我们在实例化的时候并没有初始化它指向的内存，因此我们会得到那个内存中本身剩下的值。但我们实际想做的事是将这两个变量初始化为某个特定的值，即默认为某个数，当我们没有指定或者赋值为某个值时它的值就是这个默认的数。

![image-20211112013757714](E:\newbie\cpp_code\images\image-20211112013757714.png)

有一个手动处理的方法：在调用Print方法之前先进行检查，因为当我们直接调用e时就会报出e未初始化的错误了。

```c++
int main()
{
	Entity e;
	std::cout << "X=" << e.X << ",Y=" << e.Y << std::endl;  ////////
	e.Print();
	std::cin.get();
}
```

![image-20211112014915962](E:\newbie\cpp_code\images\image-20211112014915962.png)

我们发现Print方法本身并不像我们想像的那样，它能够编译并不报错，是因为它直接打印的时X和Y，而他们俩被初始化为任意的浮点数，因此能够正常执行。

因此，一定程度上我们需要一个初始化部分，在我们每次实例化一个Entity时，如果我们设置了X和Y则给他们赋值，否则把它们设为一个默认值。比如添加一个Init方法，在实例化之后调用就可以解决初始化问题。

```c++
#include <iostream>

class Entity
{
public:
	float X, Y;

	void Init()
	{
		X = 0.0f;
		Y = 0.0f;
	}

	void Print()
	{
		std::cout << "X=" << X << ",Y=" << Y << std::endl;
	}
};

int main()
{
	Entity e;
	e.Init();
	std::cout << "X=" << e.X << ",Y=" << e.Y << std::endl;
	e.Print();
	std::cin.get();
}
```

但是可以看到我们还是需要多花一行去调用这个初始化函数，显得有点多余，代码就不够简洁。由此引出了我们的“构造函数”。

“构造函数”就是当我们实例化一个类对象时首先被调用，它的定义和其他函数一样，只是没有返回值，而且它的名字必须和class的名字相同，定义了一个构造函数之后就不需要Init方法了，下面和上面代码会得到同样的结果。

```c++
#include <iostream>

class Entity
{
public:
	float X, Y;

	Entity()
	{
		X = 0.0f;
		Y = 0.0f;
	}

	void Init()
	{
		X = 0.0f;
		Y = 0.0f;
	}

	void Print()
	{
		std::cout << "X=" << X << ",Y=" << Y << std::endl;
	}
};

int main()
{
	Entity e;
	e.Print();
	std::cin.get();
}
```

实际上当我们没有显式定义构造函数的时候，会调用一个默认的构造函数，它也被设置为默认值，但是它本身是没有做任何事的，基本上等价于

```c++
Entity()
{
}
```

在一些其它语言如Java中，像int、float这种基本类型它自动被初始化为0，但是在c++中并没有这种设定，我们需要手动给这些基本类型赋值，否则他们就被初始化为内存剩下的值了。

**注意：**

- 我们可以用任意多个构造函数，只要他们的参数是不同就行。这一原则与我们写其他同名方法是一样的，即同一方法的重载。

```c++
#include <iostream>

class Entity
{
public:
	float X, Y;

	Entity()
	{
		X = 0.0f;
		Y = 0.0f;
	}

	Entity(float x, float y)  //////////
	{
		X = x;
		Y = y;
	}

	void Init()
	{
		X = 0.0f;
		Y = 0.0f;
	}

	void Print()
	{
		std::cout << "X=" << X << ",Y=" << Y << std::endl;
	}
};

int main()
{
	Entity e(10.0f, 5.0f);
	e.Print();
	std::cin.get();
}
```

___

额外的：

如果某个类中只包含一些静态方法时，我们只想让用户通过命名空间直接调用该类中的方法而不对类进行初始化，即该类只是方法的集合，依旧是分开来使用的，而不是有机的组合起来构成一个对象，这是两种不同的策略，后者也就是我们常说的面向对象编程。

为了完成方法的集合----不调用构造函数，

1. 我们可以把构造函数藏起来，即设置为私有的。

```c++
class Log
{
private:
	Log() {};  //隐藏构造函数，就不能从外部进行实例化
public:
	static void Write()
	{

	};
};

int main()
{
    Log::Write();  //支持通过命名空间直接调用方法
    //Log l;  //当隐藏了构造函数后，该行就会报错，达到了不支持实例化效果
}
```

![image-20211112024453863](E:\newbie\cpp_code\images\image-20211112024453863.png)

2. 也可以告诉类我们不需要构造函数。

```c++
class Log
{
private:
	Log() = delete;
public:
	static void Write()
	{

	};
};

int main()
{
    Log::Write();  //支持通过命名空间直接调用方法
    //Log l;  //删除了构造函数后，该行就会报错
}
```

![image-20211112024403061](E:\newbie\cpp_code\images\image-20211112024403061.png)

___

还有一些特殊类型的构造函数，比如Copy Constructor和Move Constructor……



## 20. Destructors in C++

析构函数与构造函数类似，他是当我们要销毁一个对象时，就会调用析构函数。

构造函数通常用来设置变量默认值或者做一些其他的初始化操作的；相应的析构函数就是去初始化所有内容，并清理使用过的内存的方法。

析构函数在栈和堆对象中都适用，即我们通过new创建的（堆）对象，当我们调用delete删除它时就会调用析构函数，如果只是简单的栈对象，当命名空间或者对象要被删除时，就会调用析构函数。

```c++
~Entity()
{

}
```

```c++
#include <iostream>

class Entity
{
public:
	float X, Y;

	Entity()
	{
		X = 0.0f;
		Y = 0.0f;
		std::cout << "Created Entity!" << std::endl;
	}

	Entity(float x, float y)
	{
		X = x;
		Y = y;
	}

	void Init()
	{
		X = 0.0f;
		Y = 0.0f;
	}

	void Print()
	{
		std::cout << "X=" << X << ",Y=" << Y << std::endl;
	}

	~Entity()
	{
		std::cout << "Destroyed Entity!" << std::endl;
	}
};

void Function()
{
	Entity e;  //运行完打印第一行
	e.Print();  //运行我打印第二行
}  //运行完打印第三行


int main()
{
	Function();

	std::cin.get();
}
```

![image-20211112030501310](E:\newbie\cpp_code\images\image-20211112030501310.png)

通常，如果我们在构造函数中执行了某些初始化代码，相应的我们也会需要在析构函数中逆初始化或者删除所有的内容，如果我们不这么处理就有可能导致内存泄露。

用堆式对象来举例，如果我们手动在对上分配了一些内存，那么就必须手动去清理掉。如果狮子啊Entity的构造函数里分配了堆内存，就必须在析构函数中去清理掉，否则离开Entity之后，他的对象就被清理掉了。



## 21. Inheritance in C++

面向对象编程中最重要且最基础的特性之一就是继承，也是我们在开发过程中可使用的最强大的功能之一。

继承允许我们有一系列以层次接关系关联的类，我们可以创建一个基类只包含基本的功能，然后了可以从该基类继承去派生出不同的子类来实现其他的功能。我们再开发中使用继承的初衷就是为了避免代码重复。

如下是一个示例，Player继承自Entity，它包含了Entity类中的所有成员，Player既是Player类又是Entity类，也就是说我们可以在任何能使用Entity类的地方直接使用Player类，这就是面向对象编程的另一个基本特性**”多态性“**。而且我们只看代码中Player是无法直观知道该类中的所有成员，需要结合他的父类一起看。

简单来说，**多态性就是指一个类包含多种类型。**Player本身包含Entity中的所有对象，甚至会有一些额外成员（也可以没有），也就是说它永远是Entity的一个超子集，那么在任何使用Entity的地方直接使用Player都是可以的，因为它包含了Entity的所有属性。

> 基类中的公有成员在子类中能直接访问。
>
> 那么基类中的私有成员子类中都包含吗？？？？

```c++
#include <iostream>

class Entity  //baseclass
{
public:
	float x, y;

	void Move(float xa, float ya)
	{
		x += xa;
		y += ya;
	}
};

class Player : public Entity  //Player继承自Entity
{
public:
	const char* Name;  //额外添加的成员变量

	void PrintName()  //额外添加的成员方法
	{
		std::cout << Name << std::endl;
	}
};

int main()
{
	Player player;
	player.Move(5, 5);
	player.x = 2;  //像使用Entity一样直接使用player，直接访问他的x
	std::cin.get();
}
```



## 22. Virtual Function in C++

虚函数允许我们在子类中重写父类的方法。

假设我们有两个类A、B，B继承自A，如果我们在A类中创建一个方法并将其指定为virtual，我们就可以选择在B中覆盖该方法来实现.其他的功能

```c++
#include <iostream>
#include <string>

class Entity
{
public:
	std::string GetName() { return "Entity"; }
};

class Player : public Entity
{
public:
	std::string m_Name;
public:
	Player(const std::string& name)
		: m_Name(name){}  //这里构造函数使用了定义列表，在构造是先于函数体执行，代表将name赋值给m_Name

	std::string GetName() { return m_Name; }
};


int main()
{
	Entity* e = new Entity();
	std::cout << e->GetName() << std::endl;

	Player* p = new Player("Player");
	std::cout << p->GetName() << std::endl;

	Entity* entity = p;
	std::cout << entity->GetName() << std::endl;

	std::cin.get();
}
```

当我们想要使用一个Entity类型的指针去指向一个Player对象时，输出的结果是`Entity`的名字。到那时本身是想让它输出`Player`的，虽然使用的是Entity父类本身，但是p自身却实实在在是一个player。

![image-20211124144036362](E:\newbie\cpp_code\images\image-20211124144036362.png)

把打印名字的代码整合成方法，

```c++
#include <iostream>
#include <string>

class Entity
{
public:
	std::string GetName() { return "Entity"; }
};

class Player : public Entity
{
public:
	std::string m_Name;
public:
	Player(const std::string& name)
		: m_Name(name){}  //这里构造函数使用了定义列表，在构造是先于函数体执行，代表将name赋值给m_Name

	std::string GetName() { return m_Name; }
};


void PrintName(Entity* entity)
{
	std::cout << entity->GetName() << std::endl;
}


int main()
{
	Entity* e = new Entity();
	PrintName(e);

	Player* p = new Player("Player");
	PrintName(p);

	Entity* entity = p;
	PrintName(entity);

	std::cin.get();
}
```

发现结果输出了三次`Entity`，这并不是我们想要的。我们想要的是实际传入的是什么类型，就去调用相应类型的方法。在PrintName方法中我们可以把Player实例当作Entity实例来使用，但是他识别的是Entity的类型并直接调用该类中第7行的GetName方法，而不是我们设想的去调用Player中第18行的GetName方法。

这一诉求就移除了我们的虚函数，虚函数引入了一种叫做动态分配的东西，通常使用VTable（虚函数表）来实现此编译。虚函数表就是一个包含基类中所有虚函数的的映射，一边在运行时能够映射到正确的重写函数上。

总的来说，如果要覆盖基类中的函数，就需要在基类中将基函数标记为虚函数，仅仅只需要做一行修改，将上面第7 行代码替换为下面的，输出的结果就是我们想要的。

```c++
	virtual std::string GetName() { return "Entity"; }
```

![image-20211124145806083](E:\newbie\cpp_code\images\image-20211124145806083.png)

在c++11中引入的，子类中重写的函数可以加上`override`进行标记，它不是必要的，但是可以提高代码的可读性，而且它可以帮助我们避免一些错误，比如书写错误，即不能重写基类中没有的函数，也不能重写未标记为虚函数的函数。

---

使用虚函数不是毫无代价的，有两个运行时间损耗和虚函数有关：

1. 首先，需要额外的内存中才能将信息存储在虚函数表中，以便我们可以分派到正确的函数，该函数包含实际基类中指向虚函数表的成员指针。
2. 其次，每次调用虚函数的时候需要去遍历虚函数表一查看该映射哪个函数，这是额外的消耗；【一般不会因为性能问题而不去使用虚函数，除非是在性能特别差的嵌入式芯片上等】

```c++
#include <iostream>
#include <string>

class Entity
{
public:
	virtual std::string GetName() { return "Entity"; }
};

class Player : public Entity
{
public:
	std::string m_Name;
public:
	Player(const std::string& name)
		: m_Name(name){}  //这里构造函数使用了定义列表，在构造是先于函数体执行，代表将name赋值给m_Name

	std::string GetName() override { return m_Name; }
};


void PrintName(Entity* entity)
{
	std::cout << entity->GetName() << std::endl;
}


int main()
{
	Entity* e = new Entity();
	PrintName(e);

	Player* p = new Player("Player");
	PrintName(p);

	Entity* entity = p;
	PrintName(entity);

	std::cin.get();
}
```

### 22.1 Interfaces in C++（Pure Virtual Functions）

一种特殊的虚函数----纯虚函数，本质上就是其它语言中的抽象方法和接口，如（java和c#），它允许我们定义一个在基类中没有实现的函数，然后迫使在子类中实际实现。

在上一节的实例中，我们可以看到在Entity中有一个GetName函数，然后在Player中重写那个函数，如果在基类中的虚函数带有实际函数体，它意味着我们在子类中可以重写也可以不重写该函数，如果我们没有重写该方法，我们也可以调用player中的GetName方法，但是他是直接调用Entity中的该方法，并返回`Entity`。

然而在某些情况下提供默认实现多我们来说毫无意义，实际上我们可能想要求子类提供自己特定的函数定义。在面向对象编程中，创建一个只包含为实现方法并且交由子类去实现功能的类是非常普遍的，这通常被称为**接口**。

在接口中，类仅仅包含为实现的方法并充当一种勉强的模板，并且由于它不包含实现方法，我们是无法实例化该类。只有当我们同通过继承实现了所有的纯虚函数之后才能进行实例化。

```c++
#include <iostream>
#include <string>

class Printable
{
public:
	virtual std::string GetClassName() = 0;  //将GetClassName方法纯虚函数
};

class Entity : public Printable
{
public:
	virtual std::string GetName() { return "Entity"; }
	std::string GetClassName() override { return "Entity"; }
};

class Player : public Entity
{
public:
	std::string m_Name;
public:
	Player(const std::string& name)
		: m_Name(name) {}  //这里构造函数使用了定义列表，在构造是先于函数体执行，代表将name赋值给m_Name

	std::string GetName() override { return m_Name; }
	std::string GetClassName() override { return "Player"; }
};


void PrintName(Entity* entity)
{
	std::cout << entity->GetName() << std::endl;
}


void Print(Printable* obj)
{
	std::cout << obj->GetClassName() << std::endl;
}


int main()
{
	Entity* e = new Entity();  //不能实例化该类
	//PrintName(e);
	Print(e);

	Player* p = new Player("Player");
	//PrintName(p);
	Print(p);

	std::cin.get();
}
```



## 23. Visibility in C++

访问控制，实际上是属于面向对象编程的概念，它是说类中成员数据及成员函数的可访问性，可见性指的是谁能访问、谁能调用、谁能使用它们等等。

访问控制对于程序实际运行方式，对程序性能或者类似的性能绝对没有影响，他只是纯粹语言中存在的东西，是我们能更好地编写、组织代码，仅此而已。

### 23.1 C++中有三个基本的访问控制修饰符：

- `public`：公有，任何函数都可以访问。
- `protect`：保护，比私有好一点但是比公有弱，在该类内及所有派生类中都可以访问这些属性。
- `private`：私有，只有该类内才能访问这些变量。

> 这里还有一个`友元` `friend`标识符比较特殊，如果把一个类或者函数标记为Entity类的友元，友元是可以访问类中的私有成员的，后面会涉及到。

### 23.3 应用场景

在实际开发中将所有成员设为公有是不科学的，重要的是要考虑到书写风格、以及针对可能会阅读此代码并可能扩展的人来说如何编写易于维护易于理解的代码，它不会影响性能，也不会产生无关的代码，计算机并不理解这些，这只是人们发明出来帮助他人以及自己的理解罢了。通过指定可见性，我们可以确保别人不要调用其他不该调用的代码，进而导致一些错误。



## 24. Array in C++

```c++
int example[5];
```

int表示存储的类型，方括号中表示Array的长度，即该array能够存储5个整数，通过索引进行访问。

```c++
example[0] = 2;
```

因为c++的索引是从0开始的，长度为5的array的索引分别为[0，1，2，3，4]，如果尝试访问-1，5就会违规，在debug模式中会报错，但是在release模式下就回去直接访问不属于它的内存。

如果想去访问并设置array中的每个值，可以通过for循环来实现。

在debug模式中查看内存，可以发现`example`实际上是一个内存地址，是一个整形指针。当访问`example[4] = 2;`时，实际上是从example开始，再加上4*4(int的字节数)也就是16个字节来找到索引为4的数的。

为了验证example是一个内存地址，可以定义一个整形指针来指向example，并使用指针移动来替换array的索引操作：

```c++
#include <iostream>


int main()
{
	int example[5];
	int* ptr = example;

	for (int i = 0; i < 5; i++)
	{
		example[i] = 2;
	}

	example[2] = 5;
	*(ptr + 2) = 6;  //与example[2]指向的时相同的内存

	std::cin.get();
}
```

![image-20211124165322607](E:\newbie\cpp_code\images\image-20211124165322607.png)

第15行代码中只写了指针偏移2，但在实际的内存中偏移了8个字节，这是取决于指针的类型，整型字节就要给偏移数乘以4，2*4即是8个字节。

如果非要按字节来处理就需要通过强制转换，将int指针转为只占一个字节的char指针，同时需要给指针偏移8，拿到了起始点地址之后还需要再强制转换回int指针就能实现原来的效果，它其实就是夺银的实际作用。

```c++
*(int*)((char*)ptr + 8) = 6;
```

---

我们还可以在heap中创建array，这要用到new字段。下面两行代码开辟的空间以及是养伤都是一样的，唯一的区别就是生命周期。example在stack中，当运行到它所属的方法或类结束后就被销毁掉，而another是在heap上创建了一个array，它会一直存在直到我们手动销毁。

```c++
int example[5];
int* another = new int[5];
```

删除heap在中创建的array

```c++
delete[] another;
```

**new既然这么麻烦为什么还非要使用它呢？**

这都是由生命周期决定的，如果我们想让函数返回一个结果到其他位置时就必须使用new来分配内存，或者把结果存在某个地址中，如果不这么做，把结果存在stack中，函数结束该内存就会被释放掉。如果想要返回一个在函数中新创建的内存数据，就必须使用new关键字。

```c++
#include <iostream>

class Entity
{
public:
	int example[5];

	Entity()
	{
		for (int i = 0; i < 5; i++)
		{
			example[i] = 2;
		}
	}
};

class Entity2
{
public:
	int* another = new int[5];

	Entity2()
	{
		for (int i = 0; i < 5; i++)
		{
			another[i] = 2;
		}
	}
};


int main()
{
	Entity e;
	Entity2 e2;

	std::cin.get();
}
```



### Extra

我们是没有办法直接访问array的大小的，比如通过如下代码我们在heap中开辟了能存储5个int值的内存空间，但是是无法通过`example->size()`来获取该array的大小的。

```c++
int* example = new int[5];
```

反过来想，我们在使用delete字段释放array占用的内存空间时解析器肯定时需要知道array占用了多少空间的，也就是说是有一些方法能够获取到array的长度的：（但是是不可靠的）

```c++
int a[5];
sizeof(a)  //获取占用的总字节数
sizeof(a) / sizeof(int)  //总字节数除以数据类型占用的字节数，就能得到array的长度
```
下面给出一个示例来说明上面的计算方法为什么不可靠：

```c++
#include <iostream>

class Entity
{
public:
	int example[5];

	Entity()
	{
		int size = sizeof(example);  //20 bytes
		int count = sizeof(example) / sizeof(int);  //5
		for (int i = 0; i < 5; i++)
		{
			example[i] = 2;
		}
	}
};

class Entity2
{
public:
	int* another = new int[5];

	Entity2()
	{
		int size = sizeof(another);  //4
		int count = sizeof(another) / sizeof(int);  //1
		for (int i = 0; i < 5; i++)
		{
			another[i] = 2;
		}
	}
};


int main()
{
	Entity e;
	Entity2 e2;

	std::cin.get();
}
```

上述代码运行中，26、27行的size和count分别为4和1，与正确的20和5不一样，这是因为another本身是一个int指针，而不是array本身，因此只是统计了第一个元素并未计算整个array。

**在C++中，只能通过自行定义函数来记录array的长。**

```c++
static const int exampleSize = 5;
int example[exampleSize];
```

定义一个array时，方括号中的长度必须是一个已经编译好的常数，因此必须加上static，防止报错。<u>还有一切其他方法可以解决报错问题，如constaexpr要求变量必须是静态的，以后可能会讲到。</u>

类的完整定义如下：

```c++
class Entity
{
public:
	static const int exampleSize = 5;
	int example[exampleSize];

	Entity()
	{
		int size = sizeof(example);
		std::cout << size << std::endl;
		int count = sizeof(example) / sizeof(int);
		std::cout << count << std::endl;
		for (int i = 0; i < exampleSize; i++)
		{
			example[i] = 2;
		}
	}
};
```

另外在C++11中可以直接使用标准库array

```c++
#include <array>

std::array<int, 5> another;
another.size();  //访问array大小
```



## 25. How Strings work in  C++

Strings就是由一系列字符组成的array，字符包括数字、字母、符号等可以打印出来的东西。

> 大量复杂的引言用来介绍char、string、英文字符与其它语言字符、utf8、utf16、常见字符、扩展字符等等，以后可能会讲到，这里就只讲解最简单的一个字节的字符。

通过如下方式定义一个字符串

```
const char* name = "C++";
```

使用const标识符是想使得name是不可修改的，因为字符串是存储在一块固定大小的内存，如果我们想要存入一个更长的字符串，就需要分配新的内存来进行存储。

char 指针意味着他不是一个堆式分配，因为没有用到new来分配，肯定不能通过delete来进行删除。

因为定义为const因此不能通过索引来修改其中的某个字符串，通过查看运行时内存可以看到转换成ASCII码值的字符串。在www.AsciiTable.com来查看内存中的值实际表示的字符是什么。

![image-20211125112155683](E:\newbie\cpp_code\images\image-20211125112155683.png)

仔细观察，在我们存入的三个字符之后还有一个`00`，它是**null字符**，表示我们如何去判断一个string什么时候结束。

- **注意：c++中，单引号表示单个字符char类型；双引号表示多个字符，是char指针类型（char array），注意不是string**。

### 25.1 char, char* 和C++中字符串的基本处理方式

我们使用下面代码分别来创建两个字符串，并进行输出，

```c++
#include <iostream>

int main()
{
	const char* name = "Melissa";  //使用const标识符是想使得name是不可修改的，
	std::cout << name << std::endl;
	char name2[7] = { 'M', 'e', 'l', 'i', 's', 's', 'a' };
	std::cout << name2 << std::endl;
	std::cin.get();
}
```

会发现name2打印出了一系列奇怪的字符，查看对应内存可以发现，通过赋值每个字符的方式不会生成null结束符，因此会在读取到null字符之后才结束。

![image-20211125114040916](E:\newbie\cpp_code\images\image-20211125114040916.png)

![image-20211125114218708](E:\newbie\cpp_code\images\image-20211125114218708.png)

要使它不出错就需要给name2增加一个长度，并赋予结束字符

```c++
char name2[8] = { 'M', 'e', 'l', 'i', 's', 's', 'a', 0 };
char name2[8] = { 'M', 'e', 'l', 'i', 's', 's', 'a', '\0' };
```

### 25.2 string

c++中有一个基本的string还有一个标准库的string

iostream里面由string，但是如果我们想要打印string就必须要include <string>

```c++
#include <string>  //重载<<符号，使它可以接收string

std::string name3 = "Melissa";
```

可以通过`.size()`来获取string的size，而对于char[]和char指针都需要使用`strlen`等来获取，就比较麻烦。

**注意：**

1. 还有一些处理，比如我们想把两个字符串拼接起来，不能直接使用`+`，因为这相当于要把两个char array拼接起来。

   

   ```c++
   std::string name3 = "Melissa" + "go";
   ```

   - **双引号在C++中表示char array。**

   要想实现这一功能，可以将它拆分成两行，

   ```c++
   std::string name3 = "Melissa";
   name3 += "go";
   ```

   ![image-20211125141706880](E:\newbie\cpp_code\images\image-20211125141706880.png)

   或者把第一个字符串改为string类型，即通过string的重载+拼接字符串

   ```c++
   std::string name4 = std::string("Melissa") + "go";
   ```

2. string API的使用[string - C++ Reference (cplusplus.com)](https://www.cplusplus.com/reference/string/string/)

   ```c++
   bool contains = name3.find("sa") != std::string::npos;  //在name3中查找 sa，并返回它起点的位置
   ```

3. 在函数中传递string

   我不会这么做是因为，它是把string copy进来，如果我们在函数内部直接对输入进来的string进行操作，是不会影响原来的string的。它是在heap中开辟一块空间来存储复制已经有的数据的，这比较慢，如果我们要传递一个string，而且它是只读的，最好是使用const引用来进行传递的。

   其中`&`表示不进行复制，直接引用，`const`表示不可修改。

   ```c++
   void PrintString(const std::string& string)
   {
   	std::cout << string << std::endl;
   }
   ```

### 25.3 Strings Literals in C++

字符串就是双引号引出的一串字符，它由一串字符和最后的结束符（null 字符）组成，告诉编译器这个字符串结束了。

#### 25.3.1 普通的字符串

- 在定义一个字符串的时候，字符串的长度必须大于等于字符个数+1，这是因为最后还有一个结束符，否分就会报错，如下图所示：

  ![image-20211125150430592](E:\newbie\cpp_code\images\image-20211125150430592.png)

- 当长度比实际字符个数+1大时，多出来的空间都被赋值为null字符。

  ![image-20211125150851372](E:\newbie\cpp_code\images\image-20211125150851372.png)

- 如果我们在字符串中不小心加入了`\0`，在读到它时就会提前结束。使用`strlen`获取到的是实际的字符串长度而不是我们开辟的空间的长度。

  ![image-20211125151144239](E:\newbie\cpp_code\images\image-20211125151144239.png)

  可以注意到，上面我们使用了const来定义字符串，为的是防止我们去修改字符串，如果尝试去通过索引赋值修改其中的字符时就会报错。

  ![image-20211125151752055](E:\newbie\cpp_code\images\image-20211125151752055.png)

- **那可不可以去掉const来修改呢？**

  答案是否定的。理论上来说，我们是定义了一个char指针类型的变量来存储字符串，通过字符串索引的方式可以访问到相应的内存，但是因为**字符串是存储在只读的空间中**，是不能修改的。有些编辑器会像下图一样报错，有些会提示未定义操作，有些则不会甚至可以编译成功，我们不能依靠它来进行判断。

  ![image-20211125151958224](E:\newbie\cpp_code\images\image-20211125151958224.png)

  编译后查看源码，会发现字符串被存储在CONST SEGMENT空间中

  ![image-20211125152952048](E:\newbie\cpp_code\images\image-20211125152952048.png)

  使用HxD工具查看编译出的21_Strings.exe文件，会发现该字符串是存储在我们的二进制文件中的，当我们引用时，会引用一个const data segment，它不允许我们进行修改。

  ![image-20211125154302979](E:\newbie\cpp_code\images\image-20211125154302979.png)
  
  即使某些编译器在编译时对于给字符串中字符赋值不报错，但是实际上也是不起作用的。
  
  如果非要去修改字符串的内容，就需要通过array来定义（下面第一行）而不是指针来定义（下面第二行），千万不要这么去编程。
  
  ```c++
  char* name = "Melissa";
  char name2[] = "Melissa";
  
  char name8[] = "Melissa";
  std::cout << name8 << std::endl;
  name8[2] = '0';
  std::cout << name8 << std::endl;
  ```
  
  ![image-20211125161052431](E:\newbie\cpp_code\images\image-20211125161052431.png)
  
  通常来说，c++直接给定一个字符串就是指const的，但是如果非要赋给char*不加const的话，就要给字符串进行强制类型转换，但是进行复制同样会报错。
  
  ```c++
  char* name7 = (char*)"Melissa";
  ```
  
  ![image-20211125161612611](E:\newbie\cpp_code\images\image-20211125161612611.png)
  
  这几个示例是想说明指针型字符串不能进行修改，一定是const。

#### 25.3.2 wild 字符串

使用`wchar_t`类型来定义wild字符串，还需要给字符串前加上`L`来表示后面的字符是由wild字符组成的。

```c++
const wchar_t* name9 = L"Melissa";
```

一些其他类型字符串：

```c++
const wchar_t* name9 = L"Melissa";  //16 bits
const char16_t* name10 = u"Melissa";  //16 bits, utf16
const char32_t* name10 = U"Melissa";  //32 bits, utf32
const char* name11 = u8"Melissa";  //8 bits, utf8
```

`wchar_t`和`char16_t`看起来都是两个字节，有什么区别呢？

`wchar_t`所占位数个数都是理论上的，但是实际占用多少取决于编译器，可能是1，可能是2，也可能是4，通常情况下是2或4，在windows中是2，linux中是4。如果为了确保是2个字节建议使用`char16_t`。

#### Extra

- 其他要注意的就是，我们常在处理url时需要进行拼接操作，因此在c++14之后添加了`std::string_literals`ti工了一些便于操作的函数。

  原本我们对于两个字符串相加是不能直接处理的（下面第一行），上一届提供的方法是使用std::string进行重载（下面第二行）。除此之外，我们还可以调用std::string_literals中的方法，在第一个字符串后面加一个**`s`**进行重载。

  ```c++
  //std::string  name11 = "melissa" + "go";  //会报错
  std::string name4 = std::string("Melissa") + "go";
  
  using namespace std::string_literals;
  std::string  name11 = "melissa"s + "go";
  ```

- **`R`**重载

  需要在字符串前添加`R`在双引号内部添加小括号，就可以避免字符串太长换行导致的拼接，打印出来的字符串也是带换行符的。

  ```c++
  std::string  name12 = R"(melissa
  go
  wo)";
  ```

  ![image-20211125165415793](E:\newbie\cpp_code\images\image-20211125165415793.png)

  也可以不要任何拼接符，直接换行写字符串

  ```c++
  std::string  name15 = "melissa"
  		"go"
  		"wo";
  ```

  它打印出来的结果字符串是连着的，即没有换行符，如果需要出现在新的一行就需要手动添加`\n`，因此才需要用R重载去替代

  ![image-20211125165553007](E:\newbie\cpp_code\images\image-20211125165553007.png)

  ![image-20211125165802494](E:\newbie\cpp_code\images\image-20211125165802494.png)

  这部分内容是方便我们在代码中去写入大段的文本。

- **字符串永远被存储在只读的内存空间中**

  即使我们通过`char name8[] = "Melissa";`创建了可修改的字符串，查看编译的源代码发现，该字符串还是处在const segment中，那么他是如何实现字符串的修改呢？

  之前以指针方式创建的字符串，进行修改时，我们实际上是要去修改那个const内存，当然是不行的，而通过现在array的创建方式，在进行修改时，会先去找到那个const字符串，然后重新创建一本变量来存储相同的内容，然后再进行修改。



## 26. CONST inC++

C++中的const好像实际并没有做什么处理，只是方便了开发者去阅读，使代码可读性更高，相当于一种承诺，保证所定义的变量是常量。

### 26.1 CONST in Pointer

给出下面一个例子，对于一个指针我们可以修改它的内容，也可以修改它的地址。

```c++
#include <iostream>
#include <string>

int main()
{
	const int MAX_AGE = 90;  //定义一个常量

	int* a = new int;

	*a = 2;  //修改指针指向的内容
	std::cout << *a << std::endl;
	a = (int*)&MAX_AGE;  //修改指向的地址
	std::cout << *a << std::endl;

	std::cin.get();
}
```

根据**内容**和**地址**可修改性，指针可以分为以下四种：

1. 普通的指针

   内容和地址都可修改，如上述代码所示。

2. **指针常量**【<u>无法修改地址</u>】

   如果在定义指针变量时候，**指针变量前用const修饰**，被定义的指针变量就变成了一个指针类型的常变量，**指针类型的常变量**简称为指针常量。

   格式：`数据类型  *  const  指针变量=变量名;`

   ```c++
   char * const p="ABCDEF";
   
   p=NULL;//错误，指针常量不能再改变
   p="1234";//错误
   p=(char *)q;//错误
   *P='B'；//正确
   ```

   修饰符const与指针变量紧邻，说明指针变量不允许修改，既然指针变量的值不能修改，所以**一定要在定义的时候给定初值（指向一个确定存在的地方）**。**即指向的内存地址不能修改。但是空间中的内容可以修改。**

   ![image-20211125182026076](E:\newbie\cpp_code\images\image-20211125182026076.png)

3. **常量指针**【<u>无法修改内容</u>】

   如果在定义指针变量的时候，**数据类型前用const修饰**，被定义的指针变量就是指向常量的指针变量，**指向<u>常量</u>的<u>指针变量</u>**称为常量指针.

   格式：`const 数据类型  *指针变量=变量名;`，或者`数据类型  const  * 指针变量=变量名;`，**要求就是const必须出现在`*`之前。**

   ```c++
   const char *P="ABCDEF";
   
   *P='1';//错误，视图更改指针指向的值
   p[1]='1';//错误
   p=NULL;//正确，视图修改指针的位置，而不是修改指针指向的内容
   ```

   定义一个常量指针后，指针指向的值就不能被改变，即不能通过指针变量直接更改指针指向的值。**即指向的内存空间不能修改。但是可以指向别的地址。**

   ![image-20211125182054485](E:\newbie\cpp_code\images\image-20211125182054485.png)

4. **常指针常量**【<u>无法修改内容和地址</u>】

   格式：`const  数据类型 * const 指针变量=变量名;`或者`数据类型 const  *const 指针变量=变量名;`

   ```c++
   char *q;
   const char * const p="ABCDEF";//定义了一个常量常指针
   
   q=p;//错误，试图讲一个常指针赋值给非常指针
   p=q;//错误，试图修改指针常量的值，如1
   *p='1'；//错误，试图修改指针指向的值，如2
   p[1]='1';//错误，如2
   p=NULL；//错误，如1
   ```

   **指针不能改变，指针指向的值也不能改变。**

- 总的来说，**const在`*`之前和之后表示不同含义，但是在`数据类型`前后表示相同含义。**

![image-20211125184213286](E:\newbie\cpp_code\images\image-20211125184213286.png)

### 26.2 CONST in method（only works in class）

在类中，方法名后面的const表示该方法不能修改实际的class成员。定义一个Entity类：

```c++
class Entity
{
private:
	int m_X, m_Y;
public:
	int GetX()
	{ 
		return m_X;
	}
	int GetY()
	{
		return m_Y;
	}
};
```

给`GetY`方法后加上const约束，是表示该方法不能修改类的成员属性，否则会报错

![image-20211125185119903](E:\newbie\cpp_code\images\image-20211125185119903.png)

如果定义的属性是指针类型，还可以像下面一样操作，它的作用与上面定义为整型变量并只在方法后加上const一样。

- 第一个const表示不能修改指针指向空间的内容；
- 第二个const表示不能修改指针指向的地址；
- 第三个const表示该方法不能修改类中的成员属性。

![image-20211125185306716](E:\newbie\cpp_code\images\image-20211125185306716.png)

需要注意的是`int m_X, m_Y;`这个写法只是使得第一个变量`m_X`变成了指针，第二个变量还是整型，从下图中`GetX`和`GetY`两个方法的返回值就能看出来。

![image-20211125190138494](E:\newbie\cpp_code\images\image-20211125190138494.png)

如果想在一行定义中使得所有变量都是指针时，必须给每个变量前都加上`*`。

```C++
class Entity
{
private:
	int * m_X,* m_Y, * m_Z;
public:
	int* GetX()
	{ 
		return m_X;
	}
	int* GetY()
	{
		return m_Y;
	}
	int* GetZ()
	{
		return m_Z;
	}
};
```

### **疑问：**没搞清楚需要再看看

**观察如下代码，我们`GetX`方法本身并不进行修改类的成员属性，只是返回它的值，也就是说该方法的内容就说明了它不会修改m_X的值，那还有必要加 const 在后面吗？**

```c++
class Entity
{
private:
	int m_X;
public:
	int GetX() const
	{ 
		return m_X;
	}
};
```

答案是肯定的，const绝对保证了类成员属性不被修改。下面举例说明为什么必须加const来保证`m_X`不被修改

通常在定义一个方法时，为了不进行复制，会传入引用变量，对于引用变量我们不能修改它的值，但是可以去修改指向的地址。如果这么去定义了函数，那么对于这个类对象就只能去调用他的常方法（即不修改成员属性的方法），但如果想要调用的方法不是const就会出错。？？？？？？？？？？？？？

![image-20211125192305831](E:\newbie\cpp_code\images\image-20211125192305831.png)

### 26.3 const与mutable关键字

反过来，如果我们已经定义了某个方法为const，但是为了调试或者一些其他原因非要去修改它，那也是有办法的。

这就引出了`mutable`关键字，给类成员属性加上mutable关键字，就能够在const方法中修改成员属性。

![image-20211126100640857](E:\newbie\cpp_code\images\image-20211126100640857.png)



## 27. mutable关键字

mutable有两种用法，一个是和const一起使用，在26.3中已经提到过。另一种用法就是在lambda。

### 27.1 mutable关键字与const

如果我们在说到某个const变量是mutable的，也就是说它是常量但是是可以修改的。

![image-20211126113146284](E:\newbie\cpp_code\images\image-20211126113146284.png)

定义一个Entity类包含一个私有成员属性，并有一个常函数来返回它的值。如果我们实例化一个Entity的对象并限制为const，那么它就不能调用Entity中的非const函数，如上图所示报错。为了使得一些其他定义能够访问到GetName方法就必须将它定义为常方法，因为它本质上就是只返回m_Name，并未修改成员属性，功能就是一个常函数。

下面举个例子，为了进行调试，我们想要统计GetName常方法被调用了多少次，定义一个私有成员属性m_DebugCount来记录调试次数，并在每次调用GetName时进行自增。

这时可以发现一个矛盾的地方，**为了保证const Entity能够调用GetName方法，需要将该方法定义为常方法，但是同时它就不能修改类中的成员属性**，无法实现向我们想要的效果。

![image-20211126113818145](E:\newbie\cpp_code\images\image-20211126113818145.png)

有一个方法是将`int m_DebugCount = 0;`移到类外去，但是这回是代码比较混乱，因为这个变量只是需要在类中起作用就行，放在类外如果不小心被修改可能会改变。这时就需要用到mutable关键字来解决：

```c++
#include <iostream>
#include <string>

class Entity
{
private:
	std::string m_Name;
	mutable int m_DebugCount = 0;  //使得该变量在常方法中是可修改的
public:
	const std::string& GetName() const
	{
		m_DebugCount++;
		return m_Name;
	}
};

int main()
{
	const Entity e;
	e.GetName();

	std::cin.get();
}
```

### 27.2 mutable关键字与lambda【不常用】

#### 27.2.1 lambda表达式

在 c + + 11 及更高版本中，lambda 表达式（通常称为 " *lambda*"）是一种定义匿名函数对象的简便方法， (*关闭*) 在调用的位置或作为自变量传递给函数的位置。 通常，lambda 用于封装传递到算法或异步函数的几行代码。

 lambda 的组成部分如下：

![Lambda 表达式的结构元素的图例。](E:\newbie\cpp_code\images\images_lambda)

1. **捕获子句 (也称为 c + + 规范中的 *引导* 。 )**
2. ***参数列表* 可有可无. (也称为 *lambda 声明符*)**
3. ***可变规范* 可有可无.**
4. ***异常规范* 可有可无.**
5. ***尾随-返回类型* 可有可无.**
6. ***lambda 体*。**

##### 1.Capture子句

它指定捕获的变量以及捕获是通过值还是通过引用来捕获。

- 具有 "and" 符号 (`&`) 前缀的变量通过引用访问。

![image-20211126141418637](E:\newbie\cpp_code\images\image-20211126141418637.png)

- 空 capture 子句 `[ ]` 指示 lambda 表达式的主体不访问封闭范围中的变量。

![image-20211126141247747](E:\newbie\cpp_code\images\image-20211126141247747.png)

`[=]` 这意味着 lambda 体中引用的<u>**任何**外部变量</u>是**通过值捕获**的。

`[&]` 这意味着 lambda 体中引用的<u>**任何**外部变量</u>是**通过引用捕获**的。

可以使用**默认捕获模式**，然后**为特定变量显式指定相反的模式**。 例如，如果 lambda 体通过引用访问外部变量 `total` 并通过值访问外部变量 `factor`，则以下 capture 子句等效：

```c++
[&total, factor]
[factor, &total]
[&, factor]
[factor, &]
[=, &total]
[&total, =]
```

需要注意的是：

- **使用捕获默认值时只捕获 lambda 主体中提到的变量。**
- *如果捕获子句包含一个捕获-默认值** `&` ，**则该捕获子句捕获中的任何标识符都不能具有该格式** `&identifier` 。 同样，如果捕获子句包括捕获默认值 `=` ，则该捕获子句的捕获不能具有格式 `=identifier` 。 **标识符或 `this` 在捕获子句中不能出现多次。**
- 下面的代码段演示了一些示例：

```c++
struct S { void f(int i); };

void S::f(int i) {
    [&, i]{};      // OK
    [&, &i]{};     // ERROR: i preceded by & when & is the default
    [=, this]{};   // ERROR: this when = is the default
    [=, *this]{ }; // OK: captures this by value. See below.
    [i, i]{};      // ERROR: i repeated
}
```

若要在类成员函数的主体中使用 lambda 表达式，请将 **`this`** 指针传递给捕获子句，以提供对封闭类的成员函数和数据成员的访问。

> 当你使用 capture 子句时，建议你记住这些要点，尤其是在将 lambda 用于多线程时：
>
> - 引用捕获可用于修改外部变量，但值捕获不能。 (**`mutable`** 允许修改副本，而不是原始副本。 )
> - 引用捕获会反映外部变量的更新，而值捕获则不会。
> - 引用捕获引入生存期依赖项，而值捕获却没有生存期依赖项。 当 lambda 异步运行时，这一点尤其重要。 如果在异步 lambda 中按引用捕获本地，则在运行 lambda 时，可以轻松地实现本地。 你的代码在运行时可能会导致访问冲突。

##### 通用捕获 (C++14)

在 C++14 中，可在 Capture 子句中引入并初始化新的变量，而无需使这些变量存在于 lambda 函数的封闭范围内。 初始化可以任何任意表达式表示；且将从该表达式生成的类型推导新变量的类型。 利用此功能，您可以捕获仅移动变量 (如 `std::unique_ptr` 来自周围范围的) 并在 lambda 中使用它们。

```c++
pNums = make_unique<vector<int>>(nums);
//...
      auto a = [ptr = move(pNums)]()
        {
           // use ptr
        };
```

##### **2.参数列表**

Lambda 既可以捕获变量，也可以接受输入参数。 标准语法) (*lambda 声明符* 的参数列表是可选的，在大多数情况中，与函数的参数列表类似。

```c++
auto y = [] (int first, int second)
{
    return first + second;
};
```

在 **c + + 14** 中，如果参数类型为泛型，则可以使用 **`auto`** 关键字作为类型说明符。 此关键字指示编译器将函数调用运算符作为模板来创建。 参数列表中的每个实例 **`auto`** 都等效于不同的类型参数。

```c++
auto y = [] (auto first, auto second)
{
    return first + second;
};
```

##### **3.可变规范**

通常，lambda 的函数调用运算符是按值常数值，但使用 **`mutable`** 关键字会取消此操作。它不会生成可变的数据成员。 该 **`mutable`** 规范使 lambda 表达式的主体可以修改通过值捕获的变量。

##### 4.异常规范

您可以使用 **`noexcept`** 异常规范来指示 lambda 表达式不会引发任何异常。 与普通函数一样，如果 lambda 表达式声明 **`noexcept`** 异常规范且 lambda 体引发异常，Microsoft c + + 编译器将生成警告 C4297，如下所示：

```cpp
// throw_lambda_expression.cpp
// compile with: /W4 /EHsc
int main() // C4297 expected
{
   []() noexcept { throw 5; }();
}
```

##### 5.返回类型

将自动推导 Lambda 表达式的返回类型。 [`auto`](https://docs.microsoft.com/zh-cn/cpp/cpp/auto-cpp?view=msvc-170)除非指定 *尾随返回类型*，否则不需要使用关键字。 *尾随返回类型* 类似于普通函数或成员函数的返回类型部分。 但是，返回类型必须跟在参数列表的后面，并且必须在返回类型前面包含尾随返回类型关键字 **`->`** 。

如果 lambda 主体只包含一个返回语句，则可以省略 lambda 表达式的返回类型部分。 如果表达式不返回值，则为或。 如果 lambda 体包含单个返回语句，编译器将从返回表达式的类型推导返回类型。 否则，编译器会将返回类型推导为 **`void`** 。 请考虑以下示例代码片段，它们阐释了这一原则：

```c++
auto x1 = [](int i){ return i; }; // OK: return type is int
auto x2 = []{ return{ 1, 2 }; };  // ERROR: return type is void, deducing
                                  // return type from braced-init-list isn't valid
```

